# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-30 19:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_CN <withlihui@gmail.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../api.rst:2
msgid "API"
msgstr ""

#: ../../api.rst:6
msgid ""
"This part of the documentation covers all the interfaces of Flask.  For "
"parts where Flask depends on external libraries, we document the most "
"important right here and provide links to the canonical documentation."
msgstr ""

#: ../../api.rst:12
msgid "Application Object"
msgstr ""

#: flask.app.Flask:1 of
msgid ""
"The flask object implements a WSGI application and acts as the central "
"object.  It is passed the name of the module or package of the "
"application.  Once it is created it will act as a central registry for "
"the view functions, the URL rules, template configuration and much more."
msgstr ""

#: flask.app.Flask:6 of
msgid ""
"The name of the package is used to resolve resources from inside the "
"package or the folder the module is contained in depending on if the "
"package parameter resolves to an actual python package (a folder with an "
":file:`__init__.py` file inside) or a standard module (just a ``.py`` "
"file)."
msgstr ""

#: flask.app.Flask:11 of
msgid "For more information about resource loading, see :func:`open_resource`."
msgstr ""

#: flask.app.Flask:13 of
msgid ""
"Usually you create a :class:`Flask` instance in your main module or in "
"the :file:`__init__.py` file of your package like this::"
msgstr ""

#: flask.app.Flask:19 of
msgid "About the First Parameter"
msgstr ""

#: flask.app.Flask:21 of
msgid ""
"The idea of the first parameter is to give Flask an idea of what belongs "
"to your application.  This name is used to find resources on the "
"filesystem, can be used by extensions to improve debugging information "
"and a lot more."
msgstr ""

#: flask.app.Flask:26 of
msgid ""
"So it's important what you provide there.  If you are using a single "
"module, `__name__` is always the correct value.  If you however are using"
" a package, it's usually recommended to hardcode the name of your package"
" there."
msgstr ""

#: flask.app.Flask:31 of
msgid ""
"For example if your application is defined in "
":file:`yourapplication/app.py` you should create it with one of the two "
"versions below::"
msgstr ""

#: flask.app.Flask:37 of
msgid ""
"Why is that?  The application will work even with `__name__`, thanks to "
"how resources are looked up.  However it will make debugging more "
"painful.  Certain extensions can make assumptions based on the import "
"name of your application.  For example the Flask-SQLAlchemy extension "
"will look for the code in your application that triggered an SQL query in"
" debug mode.  If the import name is not properly set up, that debugging "
"information is lost.  (For example it would only pick up SQL queries in "
"`yourapplication.app` and not `yourapplication.views.frontend`)"
msgstr ""

#: flask.app.Flask:58 of
msgid "The ``host_matching`` and ``static_host`` parameters were added."
msgstr ""

#: flask.app.Flask:61 of
msgid ""
"The ``subdomain_matching`` parameter was added. Subdomain matching needs "
"to be enabled manually now. Setting :data:`SERVER_NAME` does not "
"implicitly enable it."
msgstr ""

#: flask.app.Flask:55 of
msgid "The `root_path` parameter was added."
msgstr ""

#: flask.app.Flask:51 of
msgid "The `instance_path` and `instance_relative_config` parameters were added."
msgstr ""

#: flask.app.Flask:47 of
msgid ""
"The `static_url_path`, `static_folder`, and `template_folder` parameters "
"were added."
msgstr ""

#: ../../api.rst ../../docstring flask.app.Flask
#: flask.app.Flask.add_template_filter flask.app.Flask.add_template_global
#: flask.app.Flask.add_template_test flask.app.Flask.add_url_rule
#: flask.app.Flask.async_to_sync flask.app.Flask.before_first_request
#: flask.app.Flask.create_url_adapter flask.app.Flask.do_teardown_appcontext
#: flask.app.Flask.do_teardown_request flask.app.Flask.ensure_sync
#: flask.app.Flask.finalize_request flask.app.Flask.handle_exception
#: flask.app.Flask.handle_http_exception flask.app.Flask.handle_url_build_error
#: flask.app.Flask.handle_user_exception flask.app.Flask.inject_url_defaults
#: flask.app.Flask.log_exception flask.app.Flask.make_config
#: flask.app.Flask.make_response flask.app.Flask.open_instance_resource
#: flask.app.Flask.process_response flask.app.Flask.raise_routing_exception
#: flask.app.Flask.register_blueprint flask.app.Flask.request_context
#: flask.app.Flask.run flask.app.Flask.select_jinja_autoescape
#: flask.app.Flask.shell_context_processor flask.app.Flask.should_ignore_error
#: flask.app.Flask.teardown_appcontext flask.app.Flask.template_filter
#: flask.app.Flask.template_global flask.app.Flask.template_test
#: flask.app.Flask.test_cli_runner flask.app.Flask.test_client
#: flask.app.Flask.test_request_context flask.app.Flask.trap_http_exception
#: flask.app.Flask.update_template_context flask.app.Flask.wsgi_app
#: flask.blueprints.Blueprint
#: flask.blueprints.Blueprint.add_app_template_filter
#: flask.blueprints.Blueprint.add_app_template_global
#: flask.blueprints.Blueprint.add_app_template_test
#: flask.blueprints.Blueprint.add_url_rule
#: flask.blueprints.Blueprint.after_app_request
#: flask.blueprints.Blueprint.app_context_processor
#: flask.blueprints.Blueprint.app_errorhandler
#: flask.blueprints.Blueprint.app_template_filter
#: flask.blueprints.Blueprint.app_template_global
#: flask.blueprints.Blueprint.app_template_test
#: flask.blueprints.Blueprint.app_url_defaults
#: flask.blueprints.Blueprint.app_url_value_preprocessor
#: flask.blueprints.Blueprint.before_app_first_request
#: flask.blueprints.Blueprint.before_app_request
#: flask.blueprints.Blueprint.make_setup_state
#: flask.blueprints.Blueprint.record flask.blueprints.Blueprint.record_once
#: flask.blueprints.Blueprint.register
#: flask.blueprints.Blueprint.register_blueprint
#: flask.blueprints.Blueprint.teardown_app_request
#: flask.blueprints.BlueprintSetupState
#: flask.blueprints.BlueprintSetupState.add_url_rule flask.cli.AppGroup
#: flask.cli.FlaskGroup flask.cli.FlaskGroup.main flask.cli.load_dotenv
#: flask.cli.run_command flask.cli.shell_command flask.config.Config
#: flask.config.Config.from_envvar flask.config.Config.from_file
#: flask.config.Config.from_json flask.config.Config.from_mapping
#: flask.config.Config.from_object flask.config.Config.from_pyfile
#: flask.config.Config.get_namespace flask.ctx.AppContext
#: flask.ctx.AppContext.pop flask.ctx.RequestContext
#: flask.ctx.RequestContext.pop flask.ctx._AppCtxGlobals.get
#: flask.ctx._AppCtxGlobals.pop flask.ctx._AppCtxGlobals.setdefault
#: flask.ctx.after_this_request flask.ctx.copy_current_request_context
#: flask.helpers.flash flask.helpers.get_flashed_messages
#: flask.helpers.get_template_attribute flask.helpers.make_response
#: flask.helpers.safe_join flask.helpers.send_file
#: flask.helpers.send_from_directory flask.helpers.stream_with_context
#: flask.helpers.url_for flask.json.JSONEncoder.default flask.json.dump
#: flask.json.dumps flask.json.jsonify flask.json.load flask.json.loads
#: flask.json.tag.JSONTag flask.json.tag.JSONTag.check
#: flask.json.tag.JSONTag.tag flask.json.tag.JSONTag.to_json
#: flask.json.tag.JSONTag.to_python flask.json.tag.TaggedJSONSerializer.dumps
#: flask.json.tag.TaggedJSONSerializer.loads
#: flask.json.tag.TaggedJSONSerializer.register
#: flask.json.tag.TaggedJSONSerializer.tag
#: flask.json.tag.TaggedJSONSerializer.untag
#: flask.scaffold.Scaffold.after_request flask.scaffold.Scaffold.before_request
#: flask.scaffold.Scaffold.context_processor flask.scaffold.Scaffold.delete
#: flask.scaffold.Scaffold.endpoint flask.scaffold.Scaffold.errorhandler
#: flask.scaffold.Scaffold.get flask.scaffold.Scaffold.get_send_file_max_age
#: flask.scaffold.Scaffold.open_resource flask.scaffold.Scaffold.patch
#: flask.scaffold.Scaffold.post flask.scaffold.Scaffold.put
#: flask.scaffold.Scaffold.register_error_handler flask.scaffold.Scaffold.route
#: flask.scaffold.Scaffold.send_static_file
#: flask.scaffold.Scaffold.teardown_request
#: flask.scaffold.Scaffold.url_defaults
#: flask.scaffold.Scaffold.url_value_preprocessor flask.sessions.NullSession
#: flask.sessions.SecureCookieSession flask.sessions.SecureCookieSession.get
#: flask.sessions.SecureCookieSession.setdefault
#: flask.sessions.SecureCookieSessionInterface.open_session
#: flask.sessions.SecureCookieSessionInterface.save_session
#: flask.sessions.SessionInterface.get_cookie_domain
#: flask.sessions.SessionInterface.get_cookie_httponly
#: flask.sessions.SessionInterface.get_cookie_name
#: flask.sessions.SessionInterface.get_cookie_path
#: flask.sessions.SessionInterface.get_cookie_samesite
#: flask.sessions.SessionInterface.get_cookie_secure
#: flask.sessions.SessionInterface.get_expiration_time
#: flask.sessions.SessionInterface.is_null_session
#: flask.sessions.SessionInterface.make_null_session
#: flask.sessions.SessionInterface.open_session
#: flask.sessions.SessionInterface.save_session
#: flask.sessions.SessionInterface.should_set_cookie
#: flask.templating.render_template flask.templating.render_template_string
#: flask.testing.FlaskCliRunner flask.testing.FlaskCliRunner.invoke
#: flask.testing.FlaskClient flask.testing.FlaskClient.open
#: flask.testing.FlaskClient.session_transaction
#: flask.views.MethodView.dispatch_request flask.views.View.as_view
#: flask.wrappers.Request flask.wrappers.Request.on_json_loading_failed
#: flask.wrappers.Response markupsafe.Markup markupsafe.Markup.escape
#: markupsafe._speedups.escape of werkzeug.exceptions.abort
#: werkzeug.sansio.response.Response.delete_cookie
#: werkzeug.sansio.response.Response.set_cookie
#: werkzeug.sansio.response.Response.set_etag werkzeug.utils.redirect
#: werkzeug.wrappers.request.Request.application
#: werkzeug.wrappers.request.Request.from_values
#: werkzeug.wrappers.request.Request.get_data
#: werkzeug.wrappers.request.Request.get_json
#: werkzeug.wrappers.response.Response.add_etag
#: werkzeug.wrappers.response.Response.call_on_close
#: werkzeug.wrappers.response.Response.force_type
#: werkzeug.wrappers.response.Response.freeze
#: werkzeug.wrappers.response.Response.from_app
#: werkzeug.wrappers.response.Response.get_app_iter
#: werkzeug.wrappers.response.Response.get_data
#: werkzeug.wrappers.response.Response.get_json
#: werkzeug.wrappers.response.Response.get_wsgi_headers
#: werkzeug.wrappers.response.Response.get_wsgi_response
#: werkzeug.wrappers.response.Response.make_conditional
#: werkzeug.wrappers.response.Response.set_data
msgid "参数"
msgstr ""

#: flask.app.Flask:66 of
msgid "the name of the application package"
msgstr ""

#: flask.app.Flask:67 of
msgid ""
"can be used to specify a different path for the static files on the web."
"  Defaults to the name of the `static_folder` folder."
msgstr ""

#: flask.app.Flask:70 of
msgid ""
"The folder with static files that is served at ``static_url_path``. "
"Relative to the application ``root_path`` or an absolute path. Defaults "
"to ``'static'``."
msgstr ""

#: flask.app.Flask:73 of
msgid ""
"the host to use when adding the static route. Defaults to None. Required "
"when using ``host_matching=True`` with a ``static_folder`` configured."
msgstr ""

#: flask.app.Flask:76 of
msgid "set ``url_map.host_matching`` attribute. Defaults to False."
msgstr ""

#: flask.app.Flask:78 of
msgid ""
"consider the subdomain relative to :data:`SERVER_NAME` when matching "
"routes. Defaults to False."
msgstr ""

#: flask.app.Flask:80 of
msgid ""
"the folder that contains the templates that should be used by the "
"application.  Defaults to ``'templates'`` folder in the root path of the "
"application."
msgstr ""

#: flask.app.Flask:84 of
msgid ""
"An alternative instance path for the application. By default the folder "
"``'instance'`` next to the package or module is assumed to be the "
"instance path."
msgstr ""

#: flask.app.Flask:88 of
msgid ""
"if set to ``True`` relative filenames for loading the config are assumed "
"to be relative to the instance path instead of the application root."
msgstr ""

#: flask.app.Flask:92 of
msgid ""
"The path to the root of the application files. This should only be set "
"manually when it can't be detected automatically, such as for namespace "
"packages."
msgstr ""

#: flask.app.Flask.add_template_filter:1 of
msgid ""
"Register a custom template filter.  Works exactly like the "
":meth:`template_filter` decorator."
msgstr ""

#: flask.app.Flask.add_template_filter:4 flask.app.Flask.template_filter:9
#: flask.blueprints.Blueprint.add_app_template_filter:5
#: flask.blueprints.Blueprint.app_template_filter:4 of
msgid "the optional name of the filter, otherwise the function name will be used."
msgstr ""

#: ../../api.rst ../../docstring flask.Request.if_match
#: flask.Request.if_none_match flask.Request.range
#: flask.app.Flask.add_template_filter flask.app.Flask.add_template_global
#: flask.app.Flask.add_template_test flask.app.Flask.add_url_rule
#: flask.app.Flask.app_context flask.app.Flask.async_to_sync
#: flask.app.Flask.auto_find_instance_path flask.app.Flask.before_first_request
#: flask.app.Flask.create_global_jinja_loader
#: flask.app.Flask.create_jinja_environment flask.app.Flask.create_url_adapter
#: flask.app.Flask.dispatch_request flask.app.Flask.do_teardown_appcontext
#: flask.app.Flask.do_teardown_request flask.app.Flask.ensure_sync
#: flask.app.Flask.finalize_request flask.app.Flask.full_dispatch_request
#: flask.app.Flask.handle_exception flask.app.Flask.handle_http_exception
#: flask.app.Flask.handle_url_build_error flask.app.Flask.handle_user_exception
#: flask.app.Flask.inject_url_defaults flask.app.Flask.iter_blueprints
#: flask.app.Flask.log_exception flask.app.Flask.make_config
#: flask.app.Flask.make_default_options_response flask.app.Flask.make_response
#: flask.app.Flask.make_shell_context flask.app.Flask.open_instance_resource
#: flask.app.Flask.preprocess_request flask.app.Flask.process_response
#: flask.app.Flask.raise_routing_exception flask.app.Flask.register_blueprint
#: flask.app.Flask.request_context flask.app.Flask.run
#: flask.app.Flask.select_jinja_autoescape
#: flask.app.Flask.shell_context_processor flask.app.Flask.should_ignore_error
#: flask.app.Flask.teardown_appcontext flask.app.Flask.template_filter
#: flask.app.Flask.template_global flask.app.Flask.template_test
#: flask.app.Flask.test_cli_runner flask.app.Flask.test_client
#: flask.app.Flask.test_request_context flask.app.Flask.trap_http_exception
#: flask.app.Flask.try_trigger_before_first_request_functions
#: flask.app.Flask.update_template_context flask.app.Flask.wsgi_app
#: flask.blueprints.Blueprint.add_app_template_filter
#: flask.blueprints.Blueprint.add_app_template_global
#: flask.blueprints.Blueprint.add_app_template_test
#: flask.blueprints.Blueprint.add_url_rule
#: flask.blueprints.Blueprint.after_app_request
#: flask.blueprints.Blueprint.app_context_processor
#: flask.blueprints.Blueprint.app_errorhandler
#: flask.blueprints.Blueprint.app_template_filter
#: flask.blueprints.Blueprint.app_template_global
#: flask.blueprints.Blueprint.app_template_test
#: flask.blueprints.Blueprint.app_url_defaults
#: flask.blueprints.Blueprint.app_url_value_preprocessor
#: flask.blueprints.Blueprint.before_app_first_request
#: flask.blueprints.Blueprint.before_app_request
#: flask.blueprints.Blueprint.make_setup_state
#: flask.blueprints.Blueprint.record flask.blueprints.Blueprint.record_once
#: flask.blueprints.Blueprint.register
#: flask.blueprints.Blueprint.register_blueprint
#: flask.blueprints.Blueprint.teardown_app_request
#: flask.blueprints.BlueprintSetupState
#: flask.blueprints.BlueprintSetupState.add_url_rule flask.cli.AppGroup
#: flask.cli.run_command flask.cli.shell_command flask.config.Config
#: flask.config.Config.from_envvar flask.config.Config.from_file
#: flask.config.Config.from_json flask.config.Config.from_mapping
#: flask.config.Config.from_object flask.config.Config.from_pyfile
#: flask.config.Config.get_namespace flask.ctx.AppContext
#: flask.ctx.AppContext.pop flask.ctx.AppContext.push flask.ctx.RequestContext
#: flask.ctx.RequestContext.copy flask.ctx.RequestContext.match_request
#: flask.ctx.RequestContext.pop flask.ctx.RequestContext.push
#: flask.ctx._AppCtxGlobals.get flask.ctx._AppCtxGlobals.pop
#: flask.ctx._AppCtxGlobals.setdefault flask.ctx.after_this_request
#: flask.ctx.copy_current_request_context flask.ctx.has_app_context
#: flask.ctx.has_request_context flask.helpers.flash
#: flask.helpers.get_flashed_messages flask.helpers.get_template_attribute
#: flask.helpers.make_response flask.helpers.safe_join
#: flask.helpers.send_from_directory flask.helpers.stream_with_context
#: flask.helpers.url_for flask.json.JSONEncoder.default flask.json.dump
#: flask.json.dumps flask.json.jsonify flask.json.load flask.json.loads
#: flask.json.tag.JSONTag flask.json.tag.JSONTag.check
#: flask.json.tag.JSONTag.tag flask.json.tag.JSONTag.to_json
#: flask.json.tag.JSONTag.to_python flask.json.tag.TaggedJSONSerializer
#: flask.json.tag.TaggedJSONSerializer.dumps
#: flask.json.tag.TaggedJSONSerializer.loads
#: flask.json.tag.TaggedJSONSerializer.register
#: flask.json.tag.TaggedJSONSerializer.tag
#: flask.json.tag.TaggedJSONSerializer.untag
#: flask.scaffold.Scaffold.after_request flask.scaffold.Scaffold.before_request
#: flask.scaffold.Scaffold.context_processor flask.scaffold.Scaffold.delete
#: flask.scaffold.Scaffold.endpoint flask.scaffold.Scaffold.errorhandler
#: flask.scaffold.Scaffold.get flask.scaffold.Scaffold.get_send_file_max_age
#: flask.scaffold.Scaffold.open_resource flask.scaffold.Scaffold.patch
#: flask.scaffold.Scaffold.post flask.scaffold.Scaffold.put
#: flask.scaffold.Scaffold.register_error_handler flask.scaffold.Scaffold.route
#: flask.scaffold.Scaffold.send_static_file
#: flask.scaffold.Scaffold.teardown_request
#: flask.scaffold.Scaffold.url_defaults
#: flask.scaffold.Scaffold.url_value_preprocessor flask.sessions.NullSession
#: flask.sessions.SecureCookieSession flask.sessions.SecureCookieSession.get
#: flask.sessions.SecureCookieSession.setdefault
#: flask.sessions.SecureCookieSessionInterface.open_session
#: flask.sessions.SecureCookieSessionInterface.save_session
#: flask.sessions.SessionInterface.get_cookie_domain
#: flask.sessions.SessionInterface.get_cookie_httponly
#: flask.sessions.SessionInterface.get_cookie_name
#: flask.sessions.SessionInterface.get_cookie_path
#: flask.sessions.SessionInterface.get_cookie_samesite
#: flask.sessions.SessionInterface.get_cookie_secure
#: flask.sessions.SessionInterface.get_expiration_time
#: flask.sessions.SessionInterface.is_null_session
#: flask.sessions.SessionInterface.make_null_session
#: flask.sessions.SessionInterface.open_session
#: flask.sessions.SessionInterface.save_session
#: flask.sessions.SessionInterface.should_set_cookie
#: flask.templating.render_template flask.templating.render_template_string
#: flask.testing.FlaskCliRunner flask.testing.FlaskCliRunner.invoke
#: flask.testing.FlaskClient flask.testing.FlaskClient.open
#: flask.testing.FlaskClient.session_transaction
#: flask.views.MethodView.dispatch_request flask.views.View.as_view
#: flask.views.View.dispatch_request flask.wrappers.Request
#: flask.wrappers.Request.on_json_loading_failed flask.wrappers.Response
#: markupsafe.Markup markupsafe.Markup.escape markupsafe.Markup.striptags
#: markupsafe.Markup.unescape of werkzeug.exceptions.abort
#: werkzeug.sansio.response.Response.delete_cookie
#: werkzeug.sansio.response.Response.get_etag
#: werkzeug.sansio.response.Response.set_cookie
#: werkzeug.sansio.response.Response.set_etag werkzeug.utils.redirect
#: werkzeug.wrappers.request.Request.application
#: werkzeug.wrappers.request.Request.close
#: werkzeug.wrappers.request.Request.from_values
#: werkzeug.wrappers.request.Request.get_data
#: werkzeug.wrappers.request.Request.get_json
#: werkzeug.wrappers.request.Request.make_form_data_parser
#: werkzeug.wrappers.response.Response.add_etag
#: werkzeug.wrappers.response.Response.calculate_content_length
#: werkzeug.wrappers.response.Response.call_on_close
#: werkzeug.wrappers.response.Response.close
#: werkzeug.wrappers.response.Response.force_type
#: werkzeug.wrappers.response.Response.freeze
#: werkzeug.wrappers.response.Response.from_app
#: werkzeug.wrappers.response.Response.get_app_iter
#: werkzeug.wrappers.response.Response.get_data
#: werkzeug.wrappers.response.Response.get_json
#: werkzeug.wrappers.response.Response.get_wsgi_headers
#: werkzeug.wrappers.response.Response.get_wsgi_response
#: werkzeug.wrappers.response.Response.iter_encoded
#: werkzeug.wrappers.response.Response.make_conditional
#: werkzeug.wrappers.response.Response.make_sequence
#: werkzeug.wrappers.response.Response.set_data
msgid "返回类型"
msgstr ""

#: flask.app.Flask.add_template_global:1 of
msgid ""
"Register a custom template global function. Works exactly like the "
":meth:`template_global` decorator."
msgstr ""

#: flask.app.Flask.add_template_global:6 flask.app.Flask.template_global:11 of
msgid ""
"the optional name of the global function, otherwise the function name "
"will be used."
msgstr ""

#: flask.app.Flask.add_template_test:1 of
msgid ""
"Register a custom template test.  Works exactly like the "
":meth:`template_test` decorator."
msgstr ""

#: flask.app.Flask.add_template_test:6 flask.app.Flask.template_test:16
#: flask.blueprints.Blueprint.add_app_template_test:7
#: flask.blueprints.Blueprint.app_template_test:6 of
msgid "the optional name of the test, otherwise the function name will be used."
msgstr ""

#: flask.app.Flask.add_url_rule:1 of
msgid ""
"Register a rule for routing incoming requests and building URLs. The "
":meth:`route` decorator is a shortcut to call this with the ``view_func``"
" argument. These are equivalent:"
msgstr ""

#: flask.app.Flask.add_url_rule:18 flask.scaffold.Scaffold.route:11 of
msgid "See :ref:`url-route-registrations`."
msgstr ""

#: flask.app.Flask.add_url_rule:20 of
msgid ""
"The endpoint name for the route defaults to the name of the view function"
" if the ``endpoint`` parameter isn't passed. An error will be raised if a"
" function has already been registered for the endpoint."
msgstr ""

#: flask.app.Flask.add_url_rule:25 of
msgid ""
"The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is always "
"added automatically, and ``OPTIONS`` is added automatically by default."
msgstr ""

#: flask.app.Flask.add_url_rule:29 of
msgid ""
"``view_func`` does not necessarily need to be passed, but if the rule "
"should participate in routing an endpoint name must be associated with a "
"view function at some point with the :meth:`endpoint` decorator."
msgstr ""

#: flask.app.Flask.add_url_rule:42 of
msgid ""
"If ``view_func`` has a ``required_methods`` attribute, those methods are "
"added to the passed and automatic methods. If it has a "
"``provide_automatic_methods`` attribute, it is used as the default if the"
" parameter is not passed."
msgstr ""

#: flask.app.Flask.add_url_rule:47 flask.scaffold.Scaffold.route:19 of
msgid "The URL rule string."
msgstr ""

#: flask.app.Flask.add_url_rule:48 of
msgid ""
"The endpoint name to associate with the rule and view function. Used when"
" routing and building URLs. Defaults to ``view_func.__name__``."
msgstr ""

#: flask.app.Flask.add_url_rule:51 of
msgid "The view function to associate with the endpoint name."
msgstr ""

#: flask.app.Flask.add_url_rule:53 of
msgid ""
"Add the ``OPTIONS`` method and respond to ``OPTIONS`` requests "
"automatically."
msgstr ""

#: flask.app.Flask.add_url_rule:55 flask.scaffold.Scaffold.route:20 of
msgid "Extra options passed to the :class:`~werkzeug.routing.Rule` object."
msgstr ""

#: flask.scaffold.Scaffold.after_request:1 of
msgid "Register a function to run after each request to this object."
msgstr ""

#: flask.scaffold.Scaffold.after_request:3 of
msgid ""
"The function is called with the response object, and must return a "
"response object. This allows the functions to modify or replace the "
"response before it is sent."
msgstr ""

#: flask.scaffold.Scaffold.after_request:7 of
msgid ""
"If a function raises an exception, any remaining ``after_request`` "
"functions will not be called. Therefore, this should not be used for "
"actions that must execute, such as to close resources. Use "
":meth:`teardown_request` for that."
msgstr ""

#: ../../docstring flask.Blueprint.after_request_funcs:1
#: flask.Flask.after_request_funcs:1 of
msgid ""
"A data structure of functions to call at the end of each request, in the "
"format ``{scope: [functions]}``. The ``scope`` key is the name of a "
"blueprint the functions are active for, or ``None`` for all requests."
msgstr ""

#: ../../docstring flask.Blueprint.after_request_funcs:6
#: flask.Flask.after_request_funcs:6 of
msgid "To register a function, use the :meth:`after_request` decorator."
msgstr ""

#: ../../docstring flask.Blueprint.after_request_funcs:9
#: flask.Blueprint.before_request_funcs:9 flask.Blueprint.error_handler_spec:12
#: flask.Blueprint.teardown_request_funcs:10
#: flask.Blueprint.template_context_processors:10
#: flask.Blueprint.url_default_functions:10
#: flask.Blueprint.url_value_preprocessors:10 flask.Blueprint.view_functions:5
#: flask.Flask.after_request_funcs:9 flask.Flask.before_request_funcs:9
#: flask.Flask.error_handler_spec:12 flask.Flask.teardown_request_funcs:10
#: flask.Flask.template_context_processors:10
#: flask.Flask.url_default_functions:10 flask.Flask.url_value_preprocessors:10
#: flask.Flask.view_functions:5 of
msgid ""
"This data structure is internal. It should not be modified directly and "
"its format may change at any time."
msgstr ""

#: flask.app.Flask.app_context:1 of
msgid ""
"Create an :class:`~flask.ctx.AppContext`. Use as a ``with`` block to push"
" the context, which will make :data:`current_app` point at this "
"application."
msgstr ""

#: flask.app.Flask.app_context:5 of
msgid ""
"An application context is automatically pushed by "
":meth:`RequestContext.push() <flask.ctx.RequestContext.push>` when "
"handling a request, and when running a CLI command. Use this to manually "
"create a context outside of these situations."
msgstr ""

#: flask.app.Flask.app_context:15 of
msgid "See :doc:`/appcontext`."
msgstr ""

#: flask.app.Flask.async_to_sync:1 of
msgid "Return a sync function that will run the coroutine function."
msgstr ""

#: flask.app.Flask.async_to_sync:7 of
msgid ""
"Override this method to change how the app converts async code to be "
"synchronously callable."
msgstr ""

#: flask.app.Flask.auto_find_instance_path:1 of
msgid ""
"Tries to locate the instance path if it was not provided to the "
"constructor of the application class.  It will basically calculate the "
"path to a folder named ``instance`` next to your main file or the "
"package."
msgstr ""

#: flask.app.Flask.before_first_request:1 of
msgid ""
"Registers a function to be run before the first request to this instance "
"of the application."
msgstr ""

#: flask.app.Flask.before_first_request:4 of
msgid ""
"The function will be called without any arguments and its return value is"
" ignored."
msgstr ""

#: ../../docstring flask.Flask.before_first_request_funcs:1 of
msgid ""
"A list of functions that will be called at the beginning of the first "
"request to this instance. To register a function, use the "
":meth:`before_first_request` decorator."
msgstr ""

#: flask.scaffold.Scaffold.before_request:1 of
msgid "Register a function to run before each request."
msgstr ""

#: flask.scaffold.Scaffold.before_request:3 of
msgid ""
"For example, this can be used to open a database connection, or to load "
"the logged in user from the session."
msgstr ""

#: flask.scaffold.Scaffold.before_request:13 of
msgid ""
"The function will be called without any arguments. If it returns a "
"non-``None`` value, the value is handled as if it was the return value "
"from the view, and further request handling is stopped."
msgstr ""

#: ../../docstring flask.Blueprint.before_request_funcs:1
#: flask.Flask.before_request_funcs:1 of
msgid ""
"A data structure of functions to call at the beginning of each request, "
"in the format ``{scope: [functions]}``. The ``scope`` key is the name of "
"a blueprint the functions are active for, or ``None`` for all requests."
msgstr ""

#: ../../docstring flask.Blueprint.before_request_funcs:6
#: flask.Flask.before_request_funcs:6 of
msgid "To register a function, use the :meth:`before_request` decorator."
msgstr ""

#: ../../docstring flask.Flask.blueprints:1 of
msgid ""
"Maps registered blueprint names to blueprint objects. The dict retains "
"the order the blueprints were registered in. Blueprints can be registered"
" multiple times, this dict does not track how often they were attached."
msgstr ""

#: ../../docstring flask.Blueprint.cli:1 flask.Flask.cli:1 of
msgid ""
"The Click command group for registering CLI commands for this object. The"
" commands are available from the ``flask`` command once the application "
"has been discovered and blueprints have been registered."
msgstr ""

#: ../../docstring flask.Flask.config:1 of
msgid ""
"The configuration dictionary as :class:`Config`.  This behaves exactly "
"like a regular dictionary but supports additional methods to load a "
"config from files."
msgstr ""

#: flask.scaffold.Scaffold.context_processor:1 of
msgid "Registers a template context processor function."
msgstr ""

#: flask.app.Flask.create_global_jinja_loader:1 of
msgid ""
"Creates the loader for the Jinja2 environment.  Can be used to override "
"just the loader and keeping the rest unchanged.  It's discouraged to "
"override this function.  Instead one should override the "
":meth:`jinja_loader` function instead."
msgstr ""

#: flask.app.Flask.create_global_jinja_loader:6 of
msgid ""
"The global loader dispatches between the loaders of the application and "
"the individual blueprints."
msgstr ""

#: flask.app.Flask.create_jinja_environment:1 of
msgid ""
"Create the Jinja environment based on :attr:`jinja_options` and the "
"various Jinja-related methods of the app. Changing :attr:`jinja_options` "
"after this will have no effect. Also adds Flask-related globals and "
"filters to the environment."
msgstr ""

#: flask.app.Flask.create_jinja_environment:6 of
msgid ""
"``Environment.auto_reload`` set in accordance with "
"``TEMPLATES_AUTO_RELOAD`` configuration option."
msgstr ""

#: flask.app.Flask.create_url_adapter:1 of
msgid ""
"Creates a URL adapter for the given request. The URL adapter is created "
"at a point where the request context is not yet set up so the request is "
"passed explicitly."
msgstr ""

#: flask.app.Flask.create_url_adapter:11 of
msgid ""
":data:`SERVER_NAME` no longer implicitly enables subdomain matching. Use "
":attr:`subdomain_matching` instead."
msgstr ""

#: flask.app.Flask.create_url_adapter:7 of
msgid ""
"This can now also be called without a request object when the URL adapter"
" is created for the application context."
msgstr ""

#: flask.Flask.debug:1 of
msgid ""
"Whether debug mode is enabled. When using ``flask run`` to start the "
"development server, an interactive debugger will be shown for unhandled "
"exceptions, and the server will be reloaded when code changes. This maps "
"to the :data:`DEBUG` config key. This is enabled when :attr:`env` is "
"``'development'`` and is overridden by the ``FLASK_DEBUG`` environment "
"variable. It may not behave as expected if set in code."
msgstr ""

#: flask.Flask.debug:9 of
msgid "**Do not enable debug mode when deploying in production.**"
msgstr ""

#: flask.Flask.debug:11 of
msgid ""
"Default: ``True`` if :attr:`env` is ``'development'``, or ``False`` "
"otherwise."
msgstr ""

#: ../../docstring flask.Flask.default_config:1 of
msgid "Default configuration parameters."
msgstr ""

#: flask.scaffold.Scaffold.delete:1 of
msgid "Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``."
msgstr ""

#: flask.app.Flask.dispatch_request:1 of
msgid ""
"Does the request dispatching.  Matches the URL and returns the return "
"value of the view or error handler.  This does not have to be a response "
"object.  In order to convert the return value to a proper response "
"object, call :func:`make_response`."
msgstr ""

#: flask.app.Flask.dispatch_request:6 of
msgid ""
"This no longer does the exception handling, this code was moved to the "
"new :meth:`full_dispatch_request`."
msgstr ""

#: flask.app.Flask.do_teardown_appcontext:1 of
msgid "Called right before the application context is popped."
msgstr ""

#: flask.app.Flask.do_teardown_appcontext:3 of
msgid ""
"When handling a request, the application context is popped after the "
"request context. See :meth:`do_teardown_request`."
msgstr ""

#: flask.app.Flask.do_teardown_appcontext:6 of
msgid ""
"This calls all functions decorated with :meth:`teardown_appcontext`. Then"
" the :data:`appcontext_tearing_down` signal is sent."
msgstr ""

#: flask.app.Flask.do_teardown_appcontext:10 of
msgid "This is called by :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`."
msgstr ""

#: flask.app.Flask.do_teardown_request:1 of
msgid ""
"Called after the request is dispatched and the response is returned, "
"right before the request context is popped."
msgstr ""

#: flask.app.Flask.do_teardown_request:4 of
msgid ""
"This calls all functions decorated with :meth:`teardown_request`, and "
":meth:`Blueprint.teardown_request` if a blueprint handled the request. "
"Finally, the :data:`request_tearing_down` signal is sent."
msgstr ""

#: flask.app.Flask.do_teardown_request:9 of
msgid ""
"This is called by :meth:`RequestContext.pop() "
"<flask.ctx.RequestContext.pop>`, which may be delayed during testing to "
"maintain access to resources."
msgstr ""

#: flask.app.Flask.do_teardown_request:14 of
msgid ""
"An unhandled exception raised while dispatching the request. Detected "
"from the current exception information if not passed. Passed to each "
"teardown function."
msgstr ""

#: flask.app.Flask.do_teardown_request:18 of
msgid "Added the ``exc`` argument."
msgstr ""

#: flask.scaffold.Scaffold.endpoint:1 of
msgid ""
"Decorate a view function to register it for the given endpoint. Used if a"
" rule is added without a ``view_func`` with :meth:`add_url_rule`."
msgstr ""

#: flask.scaffold.Scaffold.endpoint:13 of
msgid "The endpoint name to associate with the view function."
msgstr ""

#: flask.app.Flask.ensure_sync:1 of
msgid ""
"Ensure that the function is synchronous for WSGI workers. Plain ``def`` "
"functions are returned as-is. ``async def`` functions are wrapped to run "
"and wait for the response."
msgstr ""

#: flask.app.Flask.ensure_sync:5 of
msgid "Override this method to change how the app runs async views."
msgstr ""

#: ../../docstring flask.Flask.env:1 of
msgid ""
"What environment the app is running in. Flask and extensions may enable "
"behaviors based on the environment, such as enabling debug mode. This "
"maps to the :data:`ENV` config key. This is set by the "
":envvar:`FLASK_ENV` environment variable and may not behave as expected "
"if set in code."
msgstr ""

#: ../../docstring flask.Flask.env:7 of
msgid "**Do not enable development when deploying in production.**"
msgstr ""

#: ../../docstring flask.Flask.env:9 of
msgid "Default: ``'production'``"
msgstr ""

#: ../../docstring flask.Blueprint.error_handler_spec:1
#: flask.Flask.error_handler_spec:1 of
msgid ""
"A data structure of registered error handlers, in the format ``{scope: "
"{code: {class: handler}}}```. The ``scope`` key is the name of a "
"blueprint the handlers are active for, or ``None`` for all requests. The "
"``code`` key is the HTTP status code for ``HTTPException``, or ``None`` "
"for other exceptions. The innermost dictionary maps exception classes to "
"handler functions."
msgstr ""

#: ../../docstring flask.Blueprint.error_handler_spec:9
#: flask.Flask.error_handler_spec:9 of
msgid "To register an error handler, use the :meth:`errorhandler` decorator."
msgstr ""

#: flask.scaffold.Scaffold.errorhandler:1 of
msgid "Register a function to handle errors by code or exception class."
msgstr ""

#: flask.scaffold.Scaffold.errorhandler:3 of
msgid ""
"A decorator that is used to register a function given an error code.  "
"Example::"
msgstr ""

#: flask.scaffold.Scaffold.errorhandler:10 of
msgid "You can also register handlers for arbitrary exceptions::"
msgstr ""

#: flask.scaffold.Scaffold.errorhandler:16 of
msgid ""
"Use :meth:`register_error_handler` instead of modifying "
":attr:`error_handler_spec` directly, for application wide error handlers."
msgstr ""

#: flask.scaffold.Scaffold.errorhandler:21 of
msgid ""
"One can now additionally also register custom exception types that do not"
" necessarily have to be a subclass of the "
":class:`~werkzeug.exceptions.HTTPException` class."
msgstr ""

#: flask.scaffold.Scaffold.errorhandler:26 of
msgid "the code as integer for the handler, or an arbitrary exception"
msgstr ""

#: ../../docstring flask.Flask.extensions:1 of
msgid ""
"a place where extensions can store application specific state.  For "
"example this is where an extension could store database engines and "
"similar things."
msgstr ""

#: ../../docstring flask.Flask.extensions:5 of
msgid ""
"The key must match the name of the extension module. For example in case "
"of a \"Flask-Foo\" extension in `flask_foo`, the key would be ``'foo'``."
msgstr ""

#: flask.app.Flask.finalize_request:1 of
msgid ""
"Given the return value from a view function this finalizes the request by"
" converting it into a response and invoking the postprocessing functions."
"  This is invoked for both normal request dispatching as well as error "
"handlers."
msgstr ""

#: flask.app.Flask.finalize_request:6 of
msgid ""
"Because this means that it might be called as a result of a failure a "
"special safe mode is available which can be enabled with the "
"`from_error_handler` flag.  If enabled, failures in response processing "
"will be logged and otherwise ignored."
msgstr ""

#: flask.app.Flask.finalize_request flask.app.Flask.raise_routing_exception
#: flask.app.Flask.try_trigger_before_first_request_functions of
msgid "internal"
msgstr ""

#: flask.app.Flask.full_dispatch_request:1 of
msgid ""
"Dispatches the request and on top of that performs request pre and "
"postprocessing as well as HTTP exception catching and error handling."
msgstr ""

#: flask.scaffold.Scaffold.get:1 of
msgid "Shortcut for :meth:`route` with ``methods=[\"GET\"]``."
msgstr ""

#: flask.scaffold.Scaffold.get_send_file_max_age:1 of
msgid ""
"Used by :func:`send_file` to determine the ``max_age`` cache value for a "
"given file path if it wasn't passed."
msgstr ""

#: flask.scaffold.Scaffold.get_send_file_max_age:4 of
msgid ""
"By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from the "
"configuration of :data:`~flask.current_app`. This defaults to ``None``, "
"which tells the browser to use conditional requests instead of a timed "
"cache, which is usually preferable."
msgstr ""

#: flask.scaffold.Scaffold.get_send_file_max_age:9 of
msgid "The default configuration is ``None`` instead of 12 hours."
msgstr ""

#: flask.Flask.got_first_request:1 of
msgid ""
"This attribute is set to ``True`` if the application started handling the"
" first request."
msgstr ""

#: flask.app.Flask.handle_exception:1 of
msgid ""
"Handle an exception that did not have an error handler associated with "
"it, or that was raised from an error handler. This always causes a 500 "
"``InternalServerError``."
msgstr ""

#: flask.app.Flask.handle_exception:5 of
msgid "Always sends the :data:`got_request_exception` signal."
msgstr ""

#: flask.app.Flask.handle_exception:7 of
msgid ""
"If :attr:`propagate_exceptions` is ``True``, such as in debug mode, the "
"error will be re-raised so that the debugger can display it. Otherwise, "
"the original exception is logged, and an "
":exc:`~werkzeug.exceptions.InternalServerError` is returned."
msgstr ""

#: flask.app.Flask.handle_exception:12 of
msgid ""
"If an error handler is registered for ``InternalServerError`` or ``500``,"
" it will be used. For consistency, the handler will always receive the "
"``InternalServerError``. The original unhandled exception is available as"
" ``e.original_exception``."
msgstr ""

#: flask.app.Flask.handle_exception:17 of
msgid ""
"Always passes the ``InternalServerError`` instance to the handler, "
"setting ``original_exception`` to the unhandled error."
msgstr ""

#: flask.app.Flask.handle_exception:22 of
msgid ""
"``after_request`` functions and other finalization is done even for the "
"default 500 response when there is no handler."
msgstr ""

#: flask.app.Flask.handle_http_exception:1 of
msgid ""
"Handles an HTTP exception.  By default this will invoke the registered "
"error handlers and fall back to returning the exception as response."
msgstr ""

#: flask.app.Flask.handle_http_exception:5 of
msgid ""
"``RoutingException``, used internally for actions such as  slash "
"redirects during routing, is not passed to error  handlers."
msgstr ""

#: flask.app.Flask.handle_http_exception:10 of
msgid ""
"Exceptions are looked up by code *and* by MRO, so ``HTTPExcpetion`` "
"subclasses can be handled with a catch-all handler for the base "
"``HTTPException``."
msgstr ""

#: flask.app.Flask.handle_url_build_error:1 of
msgid "Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`."
msgstr ""

#: flask.app.Flask.handle_user_exception:1 of
msgid ""
"This method is called whenever an exception occurs that should be "
"handled. A special case is :class:`~werkzeug .exceptions.HTTPException` "
"which is forwarded to the :meth:`handle_http_exception` method. This "
"function will either return a response value or reraise the exception "
"with the same traceback."
msgstr ""

#: flask.app.Flask.handle_user_exception:8 of
msgid ""
"Key errors raised from request data like ``form`` show the bad key in "
"debug mode rather than a generic bad request message."
msgstr ""

#: flask.Blueprint.has_static_folder:1 flask.Flask.has_static_folder:1 of
msgid "``True`` if :attr:`static_folder` is set."
msgstr ""

#: ../../docstring flask.Blueprint.import_name:1 flask.Flask.import_name:1 of
msgid ""
"The name of the package or module that this object belongs to. Do not "
"change this once it is set by the constructor."
msgstr ""

#: flask.app.Flask.inject_url_defaults:1 of
msgid ""
"Injects the URL defaults for the given endpoint directly into the values "
"dictionary passed.  This is used internally and automatically called on "
"URL building."
msgstr ""

#: ../../docstring flask.Flask.instance_path:1 of
msgid "Holds the path to the instance folder."
msgstr ""

#: flask.app.Flask.iter_blueprints:1 of
msgid "Iterates over all blueprints by the order they were registered."
msgstr ""

#: flask.Flask.jinja_env:1 of
msgid "The Jinja environment used to load templates."
msgstr ""

#: flask.Flask.jinja_env:3 of
msgid ""
"The environment is created the first time this property is accessed. "
"Changing :attr:`jinja_options` after that will have no effect."
msgstr ""

#: flask.Blueprint.jinja_loader:1 flask.Flask.jinja_loader:1 of
msgid ""
"The Jinja loader for this object's templates. By default this is a class "
":class:`jinja2.loaders.FileSystemLoader` to :attr:`template_folder` if it"
" is set."
msgstr ""

#: ../../docstring flask.Flask.jinja_options:1 of
msgid ""
"Options that are passed to the Jinja environment in "
":meth:`create_jinja_environment`. Changing these options after the "
"environment is created (accessing :attr:`jinja_env`) will have no effect."
msgstr ""

#: ../../docstring flask.Flask.jinja_options:6 of
msgid ""
"This is a ``dict`` instead of an ``ImmutableDict`` to allow easier "
"configuration."
msgstr ""

#: flask.app.Flask.log_exception:1 of
msgid ""
"Logs an exception.  This is called by :meth:`handle_exception` if "
"debugging is disabled and right before the handler is called. The default"
" implementation logs the exception as error on the :attr:`logger`."
msgstr ""

#: flask.Flask.logger:1 of
msgid ""
"A standard Python :class:`~logging.Logger` for the app, with the same "
"name as :attr:`name`."
msgstr ""

#: flask.Flask.logger:4 of
msgid ""
"In debug mode, the logger's :attr:`~logging.Logger.level` will be set to "
":data:`~logging.DEBUG`."
msgstr ""

#: flask.Flask.logger:7 of
msgid ""
"If there are no handlers configured, a default handler will be added. See"
" :doc:`/logging` for more information."
msgstr ""

#: flask.Flask.logger:10 of
msgid ""
"The logger takes the same name as :attr:`name` rather than hard-coding "
"``\"flask.app\"``."
msgstr ""

#: flask.Flask.logger:14 of
msgid ""
"Behavior was simplified. The logger is always named ``\"flask.app\"``. "
"The level is only set during configuration, it doesn't check "
"``app.debug`` each time. Only one format is used, not different ones "
"depending on ``app.debug``. No handlers are removed, and a handler is "
"only added if no handlers are already configured."
msgstr ""

#: flask.app.Flask.make_config:1 of
msgid ""
"Used to create the config attribute by the Flask constructor. The "
"`instance_relative` parameter is passed in from the constructor of Flask "
"(there named `instance_relative_config`) and indicates if the config "
"should be relative to the instance path or the root path of the "
"application."
msgstr ""

#: flask.app.Flask.make_default_options_response:1 of
msgid ""
"This method is called to create the default ``OPTIONS`` response. This "
"can be changed through subclassing to change the default behavior of "
"``OPTIONS`` responses."
msgstr ""

#: flask.app.Flask.make_response:1 of
msgid ""
"Convert the return value from a view function to an instance of "
":attr:`response_class`."
msgstr ""

#: flask.app.Flask.make_response:4 of
msgid ""
"the return value from the view function. The view function must return a "
"response. Returning ``None``, or the view ending without returning, is "
"not allowed. The following types are allowed for ``view_rv``:  ``str``"
"     A response object is created with the string encoded to UTF-8     as"
" the body.  ``bytes``     A response object is created with the bytes as "
"the body.  ``dict``     A dictionary that will be jsonify'd before being "
"returned.  ``tuple``     Either ``(body, status, headers)``, ``(body, "
"status)``, or     ``(body, headers)``, where ``body`` is any of the other"
" types     allowed here, ``status`` is a string or an integer, and     "
"``headers`` is a dictionary or a list of ``(key, value)``     tuples. If "
"``body`` is a :attr:`response_class` instance,     ``status`` overwrites "
"the exiting value and ``headers`` are     extended.  "
":attr:`response_class`     The object is returned unchanged.  other "
":class:`~werkzeug.wrappers.Response` class     The object is coerced to "
":attr:`response_class`.  :func:`callable`     The function is called as a"
" WSGI application. The result is     used to create a response object."
msgstr ""

#: flask.app.Flask.make_response:4 of
msgid ""
"the return value from the view function. The view function must return a "
"response. Returning ``None``, or the view ending without returning, is "
"not allowed. The following types are allowed for ``view_rv``:"
msgstr ""

#: flask.app.Flask.make_response:11 of
msgid "``str``"
msgstr ""

#: flask.app.Flask.make_response:10 of
msgid "A response object is created with the string encoded to UTF-8 as the body."
msgstr ""

#: flask.app.Flask.make_response:14 of
msgid "``bytes``"
msgstr ""

#: flask.app.Flask.make_response:14 of
msgid "A response object is created with the bytes as the body."
msgstr ""

#: flask.app.Flask.make_response:17 of
msgid "``dict``"
msgstr ""

#: flask.app.Flask.make_response:17 of
msgid "A dictionary that will be jsonify'd before being returned."
msgstr ""

#: flask.app.Flask.make_response:26 of
msgid "``tuple``"
msgstr ""

#: flask.app.Flask.make_response:20 of
msgid ""
"Either ``(body, status, headers)``, ``(body, status)``, or ``(body, "
"headers)``, where ``body`` is any of the other types allowed here, "
"``status`` is a string or an integer, and ``headers`` is a dictionary or "
"a list of ``(key, value)`` tuples. If ``body`` is a "
":attr:`response_class` instance, ``status`` overwrites the exiting value "
"and ``headers`` are extended."
msgstr ""

#: flask.app.Flask.make_response:29 of
msgid ":attr:`response_class`"
msgstr ""

#: flask.app.Flask.make_response:29 of
msgid "The object is returned unchanged."
msgstr ""

#: flask.app.Flask.make_response:32 of
msgid "other :class:`~werkzeug.wrappers.Response` class"
msgstr ""

#: flask.app.Flask.make_response:32 of
msgid "The object is coerced to :attr:`response_class`."
msgstr ""

#: flask.app.Flask.make_response:36 of
msgid ":func:`callable`"
msgstr ""

#: flask.app.Flask.make_response:35 of
msgid ""
"The function is called as a WSGI application. The result is used to "
"create a response object."
msgstr ""

#: flask.app.Flask.make_response:38 of
msgid ""
"Previously a tuple was interpreted as the arguments for the response "
"object."
msgstr ""

#: flask.app.Flask.make_shell_context:1 of
msgid ""
"Returns the shell context for an interactive shell for this application."
"  This runs all the registered shell context processors."
msgstr ""

#: flask.Flask.name:1 of
msgid ""
"The name of the application.  This is usually the import name with the "
"difference that it's guessed from the run file if the import name is "
"main.  This name is used as a display name when Flask needs the name of "
"the application.  It can be set and overridden to change the value."
msgstr ""

#: flask.app.Flask.open_instance_resource:1 of
msgid ""
"Opens a resource from the application's instance folder "
"(:attr:`instance_path`).  Otherwise works like :meth:`open_resource`.  "
"Instance resources can also be opened for writing."
msgstr ""

#: flask.app.Flask.open_instance_resource:6 of
msgid ""
"the name of the resource.  To access resources within subfolders use "
"forward slashes as separator."
msgstr ""

#: flask.app.Flask.open_instance_resource:8 of
msgid "resource file opening mode, default is 'rb'."
msgstr ""

#: flask.scaffold.Scaffold.open_resource:1 of
msgid "Open a resource file relative to :attr:`root_path` for reading."
msgstr ""

#: flask.scaffold.Scaffold.open_resource:4 of
msgid ""
"For example, if the file ``schema.sql`` is next to the file ``app.py`` "
"where the ``Flask`` app is defined, it can be opened with:"
msgstr ""

#: flask.scaffold.Scaffold.open_resource:13 of
msgid "Path to the resource relative to :attr:`root_path`."
msgstr ""

#: flask.scaffold.Scaffold.open_resource:15 of
msgid ""
"Open the file in this mode. Only reading is supported, valid values are "
"\"r\" (or \"rt\") and \"rb\"."
msgstr ""

#: flask.scaffold.Scaffold.patch:1 of
msgid "Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``."
msgstr ""

#: ../../docstring flask.Flask.permanent_session_lifetime:1 of
msgid ""
"A :class:`~datetime.timedelta` which is used to set the expiration date "
"of a permanent session.  The default is 31 days which makes a permanent "
"session survive for roughly one month."
msgstr ""

#: ../../docstring flask.Flask.permanent_session_lifetime:5 of
msgid ""
"This attribute can also be configured from the config with the "
"``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to "
"``timedelta(days=31)``"
msgstr ""

#: flask.scaffold.Scaffold.post:1 of
msgid "Shortcut for :meth:`route` with ``methods=[\"POST\"]``."
msgstr ""

#: flask.app.Flask.preprocess_request:1 of
msgid ""
"Called before the request is dispatched. Calls "
":attr:`url_value_preprocessors` registered with the app and the current "
"blueprint (if any). Then calls :attr:`before_request_funcs` registered "
"with the app and the blueprint."
msgstr ""

#: flask.app.Flask.preprocess_request:6 of
msgid ""
"If any :meth:`before_request` handler returns a non-None value, the value"
" is handled as if it was the return value from the view, and further "
"request handling is stopped."
msgstr ""

#: flask.Flask.preserve_context_on_exception:1 of
msgid ""
"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration "
"value in case it's set, otherwise a sensible default is returned."
msgstr ""

#: flask.app.Flask.process_response:1 of
msgid ""
"Can be overridden in order to modify the response object before it's sent"
" to the WSGI server.  By default this will call all the "
":meth:`after_request` decorated functions."
msgstr ""

#: flask.app.Flask.process_response:5 of
msgid ""
"As of Flask 0.5 the functions registered for after request execution are "
"called in reverse order of registration."
msgstr ""

#: flask.app.Flask.process_response:9 of
msgid "a :attr:`response_class` object."
msgstr ""

#: ../../docstring flask.app.Flask.process_response flask.cli.load_dotenv
#: flask.config.Config.from_envvar flask.helpers.safe_join
#: flask.testing.FlaskCliRunner.invoke markupsafe._speedups.escape of
#: werkzeug.wrappers.request.Request.application
#: werkzeug.wrappers.request.Request.from_values
#: werkzeug.wrappers.response.Response.force_type
#: werkzeug.wrappers.response.Response.from_app
#: werkzeug.wrappers.response.Response.get_app_iter
#: werkzeug.wrappers.response.Response.get_wsgi_headers
#: werkzeug.wrappers.response.Response.get_wsgi_response
msgid "返回"
msgstr ""

#: flask.app.Flask.process_response:10 of
msgid ""
"a new response object or the same, has to be an instance of "
":attr:`response_class`."
msgstr ""

#: flask.Flask.propagate_exceptions:1 of
msgid ""
"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration value in "
"case it's set, otherwise a sensible default is returned."
msgstr ""

#: flask.scaffold.Scaffold.put:1 of
msgid "Shortcut for :meth:`route` with ``methods=[\"PUT\"]``."
msgstr ""

#: flask.app.Flask.raise_routing_exception:1 of
msgid ""
"Exceptions that are recording during routing are reraised with this "
"method.  During debug we are not reraising redirect requests for non "
"``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising a different "
"error instead to help debug situations."
msgstr ""

#: flask.app.Flask.register_blueprint:1 of
msgid ""
"Register a :class:`~flask.Blueprint` on the application. Keyword "
"arguments passed to this method will override the defaults set on the "
"blueprint."
msgstr ""

#: flask.app.Flask.register_blueprint:5 of
msgid ""
"Calls the blueprint's :meth:`~flask.Blueprint.register` method after "
"recording the blueprint in the application's :attr:`blueprints`."
msgstr ""

#: flask.app.Flask.register_blueprint:8 of
msgid "The blueprint to register."
msgstr ""

#: flask.app.Flask.register_blueprint:9 of
msgid "Blueprint routes will be prefixed with this."
msgstr ""

#: flask.app.Flask.register_blueprint:10 of
msgid "Blueprint routes will match on this subdomain."
msgstr ""

#: flask.app.Flask.register_blueprint:11 of
msgid "Blueprint routes will use these default values for view arguments."
msgstr ""

#: flask.app.Flask.register_blueprint:13 of
msgid ""
"Additional keyword arguments are passed to "
":class:`~flask.blueprints.BlueprintSetupState`. They can be accessed in "
":meth:`~flask.Blueprint.record` callbacks."
msgstr ""

#: flask.app.Flask.register_blueprint:17 flask.blueprints.Blueprint.register:16
#: flask.blueprints.Blueprint.register_blueprint:5 of
msgid ""
"The ``name`` option can be used to change the (pre-dotted) name the "
"blueprint is registered with. This allows the same blueprint to be "
"registered multiple times with unique names for ``url_for``."
msgstr ""

#: flask.scaffold.Scaffold.register_error_handler:1 of
msgid ""
"Alternative error attach function to the :meth:`errorhandler` decorator "
"that is more straightforward to use for non decorator usage."
msgstr ""

#: flask.app.Flask.request_context:1 of
msgid ""
"Create a :class:`~flask.ctx.RequestContext` representing a WSGI "
"environment. Use a ``with`` block to push the context, which will make "
":data:`request` point at this request."
msgstr ""

#: flask.app.Flask.request_context:5 flask.app.Flask.test_request_context:6 of
msgid "See :doc:`/reqcontext`."
msgstr ""

#: flask.app.Flask.request_context:7 of
msgid ""
"Typically you should not call this from your own code. A request context "
"is automatically pushed by the :meth:`wsgi_app` when handling a request. "
"Use :meth:`test_request_context` to create an environment and context "
"instead of this method."
msgstr ""

#: flask.app.Flask.request_context:12 of
msgid "a WSGI environment"
msgstr ""

#: ../../docstring flask.Blueprint.root_path:1 flask.Flask.root_path:1 of
msgid ""
"Absolute path to the package on the filesystem. Used to look up resources"
" contained in the package."
msgstr ""

#: flask.scaffold.Scaffold.route:1 of
msgid ""
"Decorate a view function to register it with the given URL rule and "
"options. Calls :meth:`add_url_rule`, which has more details about the "
"implementation."
msgstr ""

#: flask.scaffold.Scaffold.route:13 of
msgid ""
"The endpoint name for the route defaults to the name of the view function"
" if the ``endpoint`` parameter isn't passed."
msgstr ""

#: flask.scaffold.Scaffold.route:16 of
msgid ""
"The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and "
"``OPTIONS`` are added automatically."
msgstr ""

#: flask.app.Flask.run:1 of
msgid "Runs the application on a local development server."
msgstr ""

#: flask.app.Flask.run:3 of
msgid ""
"Do not use ``run()`` in a production setting. It is not intended to meet "
"security and performance requirements for a production server. Instead, "
"see :doc:`/deploying/index` for WSGI server recommendations."
msgstr ""

#: flask.app.Flask.run:7 of
msgid ""
"If the :attr:`debug` flag is set the server will automatically reload for"
" code changes and show a debugger in case an exception happened."
msgstr ""

#: flask.app.Flask.run:10 of
msgid ""
"If you want to run the application in debug mode, but disable the code "
"execution on the interactive debugger, you can pass ``use_evalex=False`` "
"as parameter.  This will keep the debugger's traceback screen active, but"
" disable code execution."
msgstr ""

#: flask.app.Flask.run:15 of
msgid ""
"It is not recommended to use this function for development with automatic"
" reloading as this is badly supported.  Instead you should be using the "
":command:`flask` command line script's ``run`` support."
msgstr ""

#: flask.app.Flask.run:19 of
msgid "Keep in Mind"
msgstr ""

#: flask.app.Flask.run:21 of
msgid ""
"Flask will suppress any server error with a generic error page unless it "
"is in debug mode.  As such to enable just the interactive debugger "
"without the code reloading, you have to invoke :meth:`run` with "
"``debug=True`` and ``use_reloader=False``. Setting ``use_debugger`` to "
"``True`` without being in debug mode won't catch any exceptions because "
"there won't be any to catch."
msgstr ""

#: flask.app.Flask.run:29 of
msgid ""
"the hostname to listen on. Set this to ``'0.0.0.0'`` to have the server "
"available externally as well. Defaults to ``'127.0.0.1'`` or the host in "
"the ``SERVER_NAME`` config variable if present."
msgstr ""

#: flask.app.Flask.run:33 of
msgid ""
"the port of the webserver. Defaults to ``5000`` or the port defined in "
"the ``SERVER_NAME`` config variable if present."
msgstr ""

#: flask.app.Flask.run:35 of
msgid "if given, enable or disable debug mode. See :attr:`debug`."
msgstr ""

#: flask.app.Flask.run:37 flask.cli.FlaskGroup:12 of
msgid ""
"Load the nearest :file:`.env` and :file:`.flaskenv` files to set "
"environment variables. Will also change the working directory to the "
"directory containing the first file found."
msgstr ""

#: flask.app.Flask.run:40 of
msgid ""
"the options to be forwarded to the underlying Werkzeug server. See "
":func:`werkzeug.serving.run_simple` for more information."
msgstr ""

#: flask.app.Flask.run:44 flask.cli.FlaskGroup:18 of
msgid ""
"If installed, python-dotenv will be used to load environment variables "
"from :file:`.env` and :file:`.flaskenv` files."
msgstr ""

#: flask.app.Flask.run:48 of
msgid ""
"If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG` environment "
"variables will override :attr:`env` and :attr:`debug`."
msgstr ""

#: flask.app.Flask.run:52 of
msgid "Threaded mode is enabled by default."
msgstr ""

#: flask.app.Flask.run:54 of
msgid "The default port is now picked from the ``SERVER_NAME`` variable."
msgstr ""

#: ../../docstring flask.Flask.secret_key:1 of
msgid ""
"If a secret key is set, cryptographic components can use this to sign "
"cookies and other things. Set this to a complex random value when you "
"want to use the secure cookie for instance."
msgstr ""

#: ../../docstring flask.Flask.secret_key:5 of
msgid ""
"This attribute can also be configured from the config with the "
":data:`SECRET_KEY` configuration key. Defaults to ``None``."
msgstr ""

#: flask.app.Flask.select_jinja_autoescape:1 of
msgid ""
"Returns ``True`` if autoescaping should be active for the given template "
"name. If no template name is given, returns `True`."
msgstr ""

#: ../../docstring flask.Flask.send_file_max_age_default:1 of
msgid ""
"A :class:`~datetime.timedelta` or number of seconds which is used as the "
"default ``max_age`` for :func:`send_file`. The default is ``None``, which"
" tells the browser to use conditional requests instead of a timed cache."
msgstr ""

#: ../../docstring flask.Flask.send_file_max_age_default:6 of
msgid "Configured with the :data:`SEND_FILE_MAX_AGE_DEFAULT` configuration key."
msgstr ""

#: ../../docstring flask.Flask.send_file_max_age_default:9 of
msgid "Defaults to ``None`` instead of 12 hours."
msgstr ""

#: flask.scaffold.Scaffold.send_static_file:1 of
msgid ""
"The view function used to serve files from :attr:`static_folder`. A route"
" is automatically registered for this view at :attr:`static_url_path` if "
":attr:`static_folder` is set."
msgstr ""

#: ../../docstring flask.Flask.session_cookie_name:1 of
msgid "The secure cookie uses this for the name of the session cookie."
msgstr ""

#: ../../docstring flask.Flask.session_cookie_name:3 of
msgid ""
"This attribute can also be configured from the config with the "
"``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``"
msgstr ""

#: ../../docstring flask.Flask.session_interface:1 of
msgid ""
"the session interface to use.  By default an instance of "
":class:`~flask.sessions.SecureCookieSessionInterface` is used here."
msgstr ""

#: flask.app.Flask.shell_context_processor:1 of
msgid "Registers a shell context processor function."
msgstr ""

#: ../../docstring flask.Flask.shell_context_processors:1 of
msgid ""
"A list of shell context processor functions that should be run when a "
"shell context is created."
msgstr ""

#: flask.app.Flask.should_ignore_error:1 of
msgid ""
"This is called to figure out if an error should be ignored or not as far "
"as the teardown system is concerned.  If this function returns ``True`` "
"then the teardown handlers will not be passed the error."
msgstr ""

#: flask.Blueprint.static_folder:1 flask.Flask.static_folder:1 of
msgid ""
"The absolute path to the configured static folder. ``None`` if no static "
"folder is set."
msgstr ""

#: flask.Blueprint.static_url_path:1 flask.Flask.static_url_path:1 of
msgid "The URL prefix that the static route will be accessible from."
msgstr ""

#: flask.Blueprint.static_url_path:3 flask.Flask.static_url_path:3 of
msgid ""
"If it was not configured during init, it is derived from "
":attr:`static_folder`."
msgstr ""

#: flask.app.Flask.teardown_appcontext:1 of
msgid ""
"Registers a function to be called when the application context ends.  "
"These functions are typically also called when the request context is "
"popped."
msgstr ""

#: flask.app.Flask.teardown_appcontext:5 flask.ctx.after_this_request:5
#: flask.ctx.copy_current_request_context:7
#: flask.scaffold.Scaffold.teardown_request:6 of
msgid "Example::"
msgstr ""

#: flask.app.Flask.teardown_appcontext:12 of
msgid ""
"When ``ctx.pop()`` is executed in the above example, the teardown "
"functions are called just before the app context moves from the stack of "
"active contexts.  This becomes relevant if you are using such constructs "
"in tests."
msgstr ""

#: flask.app.Flask.teardown_appcontext:17 of
msgid ""
"Since a request context typically also manages an application context it "
"would also be called when you pop a request context."
msgstr ""

#: flask.app.Flask.teardown_appcontext:20 of
msgid ""
"When a teardown function was called because of an unhandled exception it "
"will be passed an error object. If an :meth:`errorhandler` is registered,"
" it will handle the exception and the teardown will not receive it."
msgstr ""

#: flask.app.Flask.teardown_appcontext:25
#: flask.scaffold.Scaffold.teardown_request:26 of
msgid "The return values of teardown functions are ignored."
msgstr ""

#: ../../docstring flask.Flask.teardown_appcontext_funcs:1 of
msgid ""
"A list of functions that are called when the application context is "
"destroyed.  Since the application context is also torn down if the "
"request ends this is the place to store code that disconnects from "
"databases."
msgstr ""

#: flask.scaffold.Scaffold.teardown_request:1 of
msgid ""
"Register a function to be run at the end of each request, regardless of "
"whether there was an exception or not.  These functions are executed when"
" the request context is popped, even if not an actual request was "
"performed."
msgstr ""

#: flask.scaffold.Scaffold.teardown_request:13 of
msgid ""
"When ``ctx.pop()`` is executed in the above example, the teardown "
"functions are called just before the request context moves from the stack"
" of active contexts.  This becomes relevant if you are using such "
"constructs in tests."
msgstr ""

#: flask.scaffold.Scaffold.teardown_request:18 of
msgid ""
"Teardown functions must avoid raising exceptions, since they . If they "
"execute code that might fail they will have to surround the execution of "
"these code by try/except statements and log occurring errors."
msgstr ""

#: flask.scaffold.Scaffold.teardown_request:23 of
msgid ""
"When a teardown function was called because of an exception it will be "
"passed an error object."
msgstr ""

#: flask.scaffold.Scaffold.teardown_request:28 of
msgid "Debug Note"
msgstr ""

#: flask.scaffold.Scaffold.teardown_request:30 of
msgid ""
"In debug mode Flask will not tear down a request on an exception "
"immediately.  Instead it will keep it alive so that the interactive "
"debugger can still access it.  This behavior can be controlled by the "
"``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable."
msgstr ""

#: ../../docstring flask.Blueprint.teardown_request_funcs:1
#: flask.Flask.teardown_request_funcs:1 of
msgid ""
"A data structure of functions to call at the end of each request even if "
"an exception is raised, in the format ``{scope: [functions]}``. The "
"``scope`` key is the name of a blueprint the functions are active for, or"
" ``None`` for all requests."
msgstr ""

#: ../../docstring flask.Blueprint.teardown_request_funcs:7
#: flask.Flask.teardown_request_funcs:7 of
msgid "To register a function, use the :meth:`teardown_request` decorator."
msgstr ""

#: ../../docstring flask.Blueprint.template_context_processors:1
#: flask.Flask.template_context_processors:1 of
msgid ""
"A data structure of functions to call to pass extra context values when "
"rendering templates, in the format ``{scope: [functions]}``. The "
"``scope`` key is the name of a blueprint the functions are active for, or"
" ``None`` for all requests."
msgstr ""

#: ../../docstring flask.Blueprint.template_context_processors:7
#: flask.Flask.template_context_processors:7 of
msgid "To register a function, use the :meth:`context_processor` decorator."
msgstr ""

#: flask.app.Flask.template_filter:1 of
msgid ""
"A decorator that is used to register custom template filter. You can "
"specify a name for the filter, otherwise the function name will be used. "
"Example::"
msgstr ""

#: ../../docstring flask.Blueprint.template_folder:1
#: flask.Flask.template_folder:1 of
msgid ""
"The path to the templates folder, relative to :attr:`root_path`, to add "
"to the template loader. ``None`` if templates should not be added."
msgstr ""

#: flask.app.Flask.template_global:1 of
msgid ""
"A decorator that is used to register a custom template global function. "
"You can specify a name for the global function, otherwise the function "
"name will be used. Example::"
msgstr ""

#: flask.app.Flask.template_test:1 of
msgid ""
"A decorator that is used to register custom template test. You can "
"specify a name for the test, otherwise the function name will be used. "
"Example::"
msgstr ""

#: flask.Flask.templates_auto_reload:1 of
msgid ""
"Reload templates when they are changed. Used by "
":meth:`create_jinja_environment`."
msgstr ""

#: flask.Flask.templates_auto_reload:4 of
msgid ""
"This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If "
"not set, it will be enabled in debug mode."
msgstr ""

#: flask.Flask.templates_auto_reload:7 of
msgid ""
"This property was added but the underlying config and behavior already "
"existed."
msgstr ""

#: flask.app.Flask.test_cli_runner:1 of
msgid "Create a CLI runner for testing CLI commands. See :ref:`testing-cli`."
msgstr ""

#: flask.app.Flask.test_cli_runner:4 of
msgid ""
"Returns an instance of :attr:`test_cli_runner_class`, by default "
":class:`~flask.testing.FlaskCliRunner`. The Flask app object is passed as"
" the first argument."
msgstr ""

#: ../../docstring flask.Flask.test_cli_runner_class:1 of
msgid ""
"The :class:`~click.testing.CliRunner` subclass, by default "
":class:`~flask.testing.FlaskCliRunner` that is used by "
":meth:`test_cli_runner`. Its ``__init__`` method should take a Flask app "
"object as the first argument."
msgstr ""

#: flask.app.Flask.test_client:1 of
msgid ""
"Creates a test client for this application.  For information about unit "
"testing head over to :doc:`/testing`."
msgstr ""

#: flask.app.Flask.test_client:4 of
msgid ""
"Note that if you are testing for assertions or exceptions in your "
"application code, you must set ``app.testing = True`` in order for the "
"exceptions to propagate to the test client.  Otherwise, the exception "
"will be handled by the application (not visible to the test client) and "
"the only indication of an AssertionError or other exception will be a 500"
" status code response to the test client.  See the :attr:`testing` "
"attribute.  For example::"
msgstr ""

#: flask.app.Flask.test_client:15 of
msgid ""
"The test client can be used in a ``with`` block to defer the closing down"
" of the context until the end of the ``with`` block.  This is useful if "
"you want to access the context locals for testing::"
msgstr ""

#: flask.app.Flask.test_client:23 of
msgid ""
"Additionally, you may pass optional keyword arguments that will then be "
"passed to the application's :attr:`test_client_class` constructor. For "
"example::"
msgstr ""

#: flask.app.Flask.test_client:37 of
msgid "See :class:`~flask.testing.FlaskClient` for more information."
msgstr ""

#: flask.app.Flask.test_client:47 of
msgid ""
"Added `**kwargs` to support passing additional keyword arguments to the "
"constructor of :attr:`test_client_class`."
msgstr ""

#: flask.app.Flask.test_client:42 of
msgid ""
"The `use_cookies` parameter was added as well as the ability to override "
"the client to be used by setting the :attr:`test_client_class` attribute."
msgstr ""

#: flask.app.Flask.test_client:39 of
msgid "added support for ``with`` block usage for the client."
msgstr ""

#: ../../docstring flask.Flask.test_client_class:1 of
msgid "the test client that is used with when `test_client` is used."
msgstr ""

#: flask.app.Flask.test_request_context:1 of
msgid ""
"Create a :class:`~flask.ctx.RequestContext` for a WSGI environment "
"created from the given values. This is mostly useful during testing, "
"where you may want to run a function that uses request data without "
"dispatching a full request."
msgstr ""

#: flask.app.Flask.test_request_context:8 of
msgid ""
"Use a ``with`` block to push the context, which will make :data:`request`"
" point at the request for the created environment. ::"
msgstr ""

#: flask.app.Flask.test_request_context:15 of
msgid ""
"When using the shell, it may be easier to push and pop the context "
"manually to avoid indentation. ::"
msgstr ""

#: flask.app.Flask.test_request_context:23 of
msgid ""
"Takes the same arguments as Werkzeug's "
":class:`~werkzeug.test.EnvironBuilder`, with some defaults from the "
"application. See the linked Werkzeug docs for most of the available "
"arguments. Flask-specific behavior is listed here."
msgstr ""

#: flask.app.Flask.test_request_context:28 of
msgid "URL path being requested."
msgstr ""

#: flask.app.Flask.test_request_context:29 of
msgid ""
"Base URL where the app is being served, which ``path`` is relative to. If"
" not given, built from :data:`PREFERRED_URL_SCHEME`, ``subdomain``, "
":data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`."
msgstr ""

#: flask.app.Flask.test_request_context:33 of
msgid "Subdomain name to append to :data:`SERVER_NAME`."
msgstr ""

#: flask.app.Flask.test_request_context:35 of
msgid "Scheme to use instead of :data:`PREFERRED_URL_SCHEME`."
msgstr ""

#: flask.app.Flask.test_request_context:37 of
msgid "The request body, either as a string or a dict of form keys and values."
msgstr ""

#: flask.app.Flask.test_request_context:39 of
msgid ""
"If given, this is serialized as JSON and passed as ``data``. Also "
"defaults ``content_type`` to ``application/json``."
msgstr ""

#: flask.app.Flask.test_request_context:42 of
msgid ""
"other positional arguments passed to "
":class:`~werkzeug.test.EnvironBuilder`."
msgstr ""

#: flask.app.Flask.test_request_context:44 of
msgid "other keyword arguments passed to :class:`~werkzeug.test.EnvironBuilder`."
msgstr ""

#: ../../docstring flask.Flask.testing:1 of
msgid ""
"The testing flag.  Set this to ``True`` to enable the test mode of Flask "
"extensions (and in the future probably also Flask itself). For example "
"this might activate test helpers that have an additional runtime cost "
"which should not be enabled by default."
msgstr ""

#: ../../docstring flask.Flask.testing:6 of
msgid ""
"If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the "
"default it's implicitly enabled."
msgstr ""

#: ../../docstring flask.Flask.testing:9 of
msgid ""
"This attribute can also be configured from the config with the "
"``TESTING`` configuration key.  Defaults to ``False``."
msgstr ""

#: flask.app.Flask.trap_http_exception:1 of
msgid ""
"Checks if an HTTP exception should be trapped or not.  By default this "
"will return ``False`` for all exceptions except for a bad request key "
"error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It also returns"
" ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``."
msgstr ""

#: flask.app.Flask.trap_http_exception:6 of
msgid ""
"This is called for all HTTP exceptions raised by a view function. If it "
"returns ``True`` for any exception the error handler for this exception "
"is not called and it shows up as regular exception in the traceback.  "
"This is helpful for debugging implicitly raised HTTP exceptions."
msgstr ""

#: flask.app.Flask.trap_http_exception:12 of
msgid "Bad request errors are not trapped by default in debug mode."
msgstr ""

#: flask.app.Flask.try_trigger_before_first_request_functions:1 of
msgid ""
"Called before each request and will ensure that it triggers the "
":attr:`before_first_request_funcs` and only exactly once per application "
"instance (which means process usually)."
msgstr ""

#: flask.app.Flask.update_template_context:1 of
msgid ""
"Update the template context with some commonly used variables. This "
"injects request, session, config and g into the template context as well "
"as everything template context processors want to inject.  Note that the "
"as of Flask 0.6, the original values in the context will not be "
"overridden if a context processor decides to return a value with the same"
" key."
msgstr ""

#: flask.app.Flask.update_template_context:8 of
msgid ""
"the context as a dictionary that is updated in place to add extra "
"variables."
msgstr ""

#: ../../docstring flask.Flask.url_build_error_handlers:1 of
msgid ""
"A list of functions that are called when :meth:`url_for` raises a "
":exc:`~werkzeug.routing.BuildError`.  Each function registered here is "
"called with `error`, `endpoint` and `values`.  If a function returns "
"``None`` or raises a :exc:`BuildError` the next function is tried."
msgstr ""

#: ../../docstring flask.Blueprint.url_default_functions:1
#: flask.Flask.url_default_functions:1 of
msgid ""
"A data structure of functions to call to modify the keyword arguments "
"when generating URLs, in the format ``{scope: [functions]}``. The "
"``scope`` key is the name of a blueprint the functions are active for, or"
" ``None`` for all requests."
msgstr ""

#: ../../docstring flask.Blueprint.url_default_functions:7
#: flask.Flask.url_default_functions:7 of
msgid "To register a function, use the :meth:`url_defaults` decorator."
msgstr ""

#: flask.scaffold.Scaffold.url_defaults:1 of
msgid ""
"Callback function for URL defaults for all view functions of the "
"application.  It's called with the endpoint and values and should update "
"the values passed in place."
msgstr ""

#: ../../docstring flask.Flask.url_map:1 of
msgid ""
"The :class:`~werkzeug.routing.Map` for this instance.  You can use this "
"to change the routing converters after the class was created but before "
"any routes are connected.  Example::"
msgstr ""

#: flask.scaffold.Scaffold.url_value_preprocessor:1 of
msgid ""
"Register a URL value preprocessor function for all view functions in the "
"application. These functions will be called before the "
":meth:`before_request` functions."
msgstr ""

#: flask.scaffold.Scaffold.url_value_preprocessor:5 of
msgid ""
"The function can modify the values captured from the matched url before "
"they are passed to the view. For example, this can be used to pop a "
"common language code value and place it in ``g`` rather than pass it to "
"every view."
msgstr ""

#: flask.scaffold.Scaffold.url_value_preprocessor:10 of
msgid ""
"The function is passed the endpoint name and values dict. The return "
"value is ignored."
msgstr ""

#: ../../docstring flask.Blueprint.url_value_preprocessors:1
#: flask.Flask.url_value_preprocessors:1 of
msgid ""
"A data structure of functions to call to modify the keyword arguments "
"passed to the view function, in the format ``{scope: [functions]}``. The "
"``scope`` key is the name of a blueprint the functions are active for, or"
" ``None`` for all requests."
msgstr ""

#: ../../docstring flask.Blueprint.url_value_preprocessors:7
#: flask.Flask.url_value_preprocessors:7 of
msgid "To register a function, use the :meth:`url_value_preprocessor` decorator."
msgstr ""

#: ../../docstring flask.Flask.use_x_sendfile:1 of
msgid ""
"Enable this if you want to use the X-Sendfile feature.  Keep in mind that"
" the server has to support this.  This only affects files sent with the "
":func:`send_file` method."
msgstr ""

#: ../../docstring flask.Flask.use_x_sendfile:7 of
msgid ""
"This attribute can also be configured from the config with the "
"``USE_X_SENDFILE`` configuration key.  Defaults to ``False``."
msgstr ""

#: ../../docstring flask.Blueprint.view_functions:1
#: flask.Flask.view_functions:1 of
msgid "A dictionary mapping endpoint names to view functions."
msgstr ""

#: ../../docstring flask.Blueprint.view_functions:3
#: flask.Flask.view_functions:3 of
msgid "To register a view function, use the :meth:`route` decorator."
msgstr ""

#: flask.app.Flask.wsgi_app:1 of
msgid ""
"The actual WSGI application. This is not implemented in :meth:`__call__` "
"so that middlewares can be applied without losing a reference to the app "
"object. Instead of doing this::"
msgstr ""

#: flask.app.Flask.wsgi_app:7 of
msgid "It's a better idea to do this instead::"
msgstr ""

#: flask.app.Flask.wsgi_app:11 of
msgid ""
"Then you still have the original application object around and can "
"continue to call methods on it."
msgstr ""

#: flask.app.Flask.wsgi_app:14 of
msgid ""
"Teardown events for the request and app contexts are called even if an "
"unhandled error occurs. Other events may not be called depending on when "
"an error occurs during dispatch. See :ref:`callbacks-and-errors`."
msgstr ""

#: flask.app.Flask.wsgi_app:20 of
msgid "A WSGI environment."
msgstr ""

#: flask.app.Flask.wsgi_app:21 of
msgid ""
"A callable accepting a status code, a list of headers, and an optional "
"exception context to start the response."
msgstr ""

#: ../../api.rst:20
msgid "Blueprint Objects"
msgstr ""

#: flask.blueprints.Blueprint:1 of
msgid ""
"Represents a blueprint, a collection of routes and other app-related "
"functions that can be registered on a real application later."
msgstr ""

#: flask.blueprints.Blueprint:5 of
msgid ""
"A blueprint is an object that allows defining application functions "
"without requiring an application object ahead of time. It uses the same "
"decorators as :class:`~flask.Flask`, but defers the need for an "
"application by recording them for later registration."
msgstr ""

#: flask.blueprints.Blueprint:10 of
msgid ""
"Decorating a function with a blueprint creates a deferred function that "
"is called with :class:`~flask.blueprints.BlueprintSetupState` when the "
"blueprint is registered on an application."
msgstr ""

#: flask.blueprints.Blueprint:14 of
msgid "See :doc:`/blueprints` for more information."
msgstr ""

#: flask.blueprints.Blueprint:16 of
msgid "The name of the blueprint. Will be prepended to each endpoint name."
msgstr ""

#: flask.blueprints.Blueprint:18 of
msgid ""
"The name of the blueprint package, usually ``__name__``. This helps "
"locate the ``root_path`` for the blueprint."
msgstr ""

#: flask.blueprints.Blueprint:21 of
msgid ""
"A folder with static files that should be served by the blueprint's "
"static route. The path is relative to the blueprint's root path. "
"Blueprint static files are disabled by default."
msgstr ""

#: flask.blueprints.Blueprint:25 of
msgid ""
"The url to serve static files from. Defaults to ``static_folder``. If the"
" blueprint does not have a ``url_prefix``, the app's static route will "
"take precedence, and the blueprint's static files won't be accessible."
msgstr ""

#: flask.blueprints.Blueprint:29 of
msgid ""
"A folder with templates that should be added to the app's template search"
" path. The path is relative to the blueprint's root path. Blueprint "
"templates are disabled by default. Blueprint templates have a lower "
"precedence than those in the app's templates folder."
msgstr ""

#: flask.blueprints.Blueprint:34 of
msgid ""
"A path to prepend to all of the blueprint's URLs, to make them distinct "
"from the rest of the app's routes."
msgstr ""

#: flask.blueprints.Blueprint:36 of
msgid "A subdomain that blueprint routes will match on by default."
msgstr ""

#: flask.blueprints.Blueprint:38 of
msgid "A dict of default values that blueprint routes will receive by default."
msgstr ""

#: flask.blueprints.Blueprint:40 of
msgid ""
"By default, the blueprint will automatically set this based on "
"``import_name``. In certain situations this automatic detection can fail,"
" so the path can be specified manually instead."
msgstr ""

#: flask.blueprints.Blueprint:45 of
msgid ""
"Blueprints have a ``cli`` group to register nested CLI commands. The "
"``cli_group`` parameter controls the name of the group under the "
"``flask`` command."
msgstr ""

#: flask.blueprints.Blueprint.add_app_template_filter:1 of
msgid ""
"Register a custom template filter, available application wide.  Like "
":meth:`Flask.add_template_filter` but for a blueprint.  Works exactly "
"like the :meth:`app_template_filter` decorator."
msgstr ""

#: flask.blueprints.Blueprint.add_app_template_global:1 of
msgid ""
"Register a custom template global, available application wide.  Like "
":meth:`Flask.add_template_global` but for a blueprint.  Works exactly "
"like the :meth:`app_template_global` decorator."
msgstr ""

#: flask.blueprints.Blueprint.add_app_template_global:7
#: flask.blueprints.Blueprint.app_template_global:6 of
msgid "the optional name of the global, otherwise the function name will be used."
msgstr ""

#: flask.blueprints.Blueprint.add_app_template_test:1 of
msgid ""
"Register a custom template test, available application wide.  Like "
":meth:`Flask.add_template_test` but for a blueprint.  Works exactly like "
"the :meth:`app_template_test` decorator."
msgstr ""

#: flask.blueprints.Blueprint.add_url_rule:1 of
msgid ""
"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for "
"the :func:`url_for` function is prefixed with the name of the blueprint."
msgstr ""

#: flask.blueprints.Blueprint.after_app_request:1 of
msgid ""
"Like :meth:`Flask.after_request` but for a blueprint.  Such a function is"
" executed after each request, even if outside of the blueprint."
msgstr ""

#: flask.blueprints.Blueprint.app_context_processor:1 of
msgid ""
"Like :meth:`Flask.context_processor` but for a blueprint.  Such a "
"function is executed each request, even if outside of the blueprint."
msgstr ""

#: flask.blueprints.Blueprint.app_errorhandler:1 of
msgid ""
"Like :meth:`Flask.errorhandler` but for a blueprint.  This handler is "
"used for all requests, even if outside of the blueprint."
msgstr ""

#: flask.blueprints.Blueprint.app_template_filter:1 of
msgid ""
"Register a custom template filter, available application wide.  Like "
":meth:`Flask.template_filter` but for a blueprint."
msgstr ""

#: flask.blueprints.Blueprint.app_template_global:1 of
msgid ""
"Register a custom template global, available application wide.  Like "
":meth:`Flask.template_global` but for a blueprint."
msgstr ""

#: flask.blueprints.Blueprint.app_template_test:1 of
msgid ""
"Register a custom template test, available application wide.  Like "
":meth:`Flask.template_test` but for a blueprint."
msgstr ""

#: flask.blueprints.Blueprint.app_url_defaults:1 of
msgid "Same as :meth:`url_defaults` but application wide."
msgstr ""

#: flask.blueprints.Blueprint.app_url_value_preprocessor:1 of
msgid "Same as :meth:`url_value_preprocessor` but application wide."
msgstr ""

#: flask.blueprints.Blueprint.before_app_first_request:1 of
msgid ""
"Like :meth:`Flask.before_first_request`.  Such a function is executed "
"before the first request to the application."
msgstr ""

#: flask.blueprints.Blueprint.before_app_request:1 of
msgid ""
"Like :meth:`Flask.before_request`.  Such a function is executed before "
"each request, even if outside of a blueprint."
msgstr ""

#: ../../docstring flask.Blueprint.json_decoder:1 of
msgid ""
"Blueprint local JSON decoder class to use. Set to ``None`` to use the "
"app's :class:`~flask.Flask.json_decoder`."
msgstr ""

#: ../../docstring flask.Blueprint.json_encoder:1 of
msgid ""
"Blueprint local JSON encoder class to use. Set to ``None`` to use the "
"app's :class:`~flask.Flask.json_encoder`."
msgstr ""

#: flask.blueprints.Blueprint.make_setup_state:1 of
msgid ""
"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState` "
"object that is later passed to the register callback functions. "
"Subclasses can override this to return a subclass of the setup state."
msgstr ""

#: flask.blueprints.Blueprint.record:1 of
msgid ""
"Registers a function that is called when the blueprint is registered on "
"the application.  This function is called with the state as argument as "
"returned by the :meth:`make_setup_state` method."
msgstr ""

#: flask.blueprints.Blueprint.record_once:1 of
msgid ""
"Works like :meth:`record` but wraps the function in another function that"
" will ensure the function is only called once.  If the blueprint is "
"registered a second time on the application, the function passed is not "
"called."
msgstr ""

#: flask.blueprints.Blueprint.register:1 of
msgid ""
"Called by :meth:`Flask.register_blueprint` to register all views and "
"callbacks registered on the blueprint with the application. Creates a "
":class:`.BlueprintSetupState` and calls each :meth:`record` callback with"
" it."
msgstr ""

#: flask.blueprints.Blueprint.register:6 of
msgid "The application this blueprint is being registered with."
msgstr ""

#: flask.blueprints.Blueprint.register:8 of
msgid "Keyword arguments forwarded from :meth:`~Flask.register_blueprint`."
msgstr ""

#: flask.blueprints.Blueprint.register:11 of
msgid ""
"Nested blueprints are registered with their dotted name. This allows "
"different blueprints with the same name to be nested at different "
"locations."
msgstr ""

#: flask.blueprints.Blueprint.register:22 of
msgid ""
"Registering the same blueprint with the same name multiple times is "
"deprecated and will become an error in Flask 2.1."
msgstr ""

#: flask.blueprints.Blueprint.register_blueprint:1 of
msgid ""
"Register a :class:`~flask.Blueprint` on this blueprint. Keyword arguments"
" passed to this method will override the defaults set on the blueprint."
msgstr ""

#: flask.blueprints.Blueprint.teardown_app_request:1 of
msgid ""
"Like :meth:`Flask.teardown_request` but for a blueprint.  Such a function"
" is executed when tearing down each request, even if outside of the "
"blueprint."
msgstr ""

#: ../../api.rst:27
msgid "Incoming Request Data"
msgstr ""

#: flask.wrappers.Request:1 of
msgid ""
"The request object used by default in Flask.  Remembers the matched "
"endpoint and view arguments."
msgstr ""

#: flask.wrappers.Request:4 of
msgid ""
"It is what ends up as :class:`~flask.request`.  If you want to replace "
"the request object used you can subclass this and set "
":attr:`~flask.Flask.request_class` to your subclass."
msgstr ""

#: flask.wrappers.Request:8 of
msgid ""
"The request object is a :class:`~werkzeug.wrappers.Request` subclass and "
"provides all of the attributes Werkzeug defines plus a few Flask specific"
" ones."
msgstr ""

#: flask.Request.accept_charsets:1 of
msgid ""
"List of charsets this client supports as "
":class:`~werkzeug.datastructures.CharsetAccept` object."
msgstr ""

#: flask.Request.accept_encodings:1 of
msgid ""
"List of encodings this client accepts.  Encodings in a HTTP term are "
"compression encodings such as gzip.  For charsets have a look at "
":attr:`accept_charset`."
msgstr ""

#: flask.Request.accept_languages:1 of
msgid ""
"List of languages this client accepts as "
":class:`~werkzeug.datastructures.LanguageAccept` object."
msgstr ""

#: flask.Request.accept_mimetypes:1 of
msgid ""
"List of mimetypes this client supports as "
":class:`~werkzeug.datastructures.MIMEAccept` object."
msgstr ""

#: ../../docstring flask.Request.access_control_request_headers:1 of
msgid ""
"Sent with a preflight request to indicate which headers will be sent with"
" the cross origin request. Set "
":attr:`~CORSResponseMixin.access_control_allow_headers` on the response "
"to indicate which headers are allowed."
msgstr ""

#: ../../docstring flask.Request.access_control_request_method:1 of
msgid ""
"Sent with a preflight request to indicate which method will be used for "
"the cross origin request. Set "
":attr:`~CORSResponseMixin.access_control_allow_methods` on the response "
"to indicate which methods are allowed."
msgstr ""

#: flask.Request.access_route:1 of
msgid ""
"If a forwarded header exists this is a list of all ip addresses from the "
"client ip to the last proxy server."
msgstr ""

#: of werkzeug.wrappers.request.Request.application:1
msgid ""
"Decorate a function as responder that accepts the request as the last "
"argument.  This works like the :func:`responder` decorator but the "
"function is passed the request object as the last argument and the "
"request object will be closed automatically::"
msgstr ""

#: of werkzeug.wrappers.request.Request.application:11
msgid ""
"As of Werkzeug 0.14 HTTP exceptions are automatically caught and "
"converted to responses instead of failing."
msgstr ""

#: of werkzeug.wrappers.request.Request.application:14
msgid "the WSGI callable to decorate"
msgstr ""

#: of werkzeug.wrappers.request.Request.application:15
msgid "a new WSGI callable"
msgstr ""

#: flask.Request.args:1 of
msgid "The parsed URL parameters (the part in the URL after the question mark)."
msgstr ""

#: flask.Request.args:4 of
msgid ""
"By default an :class:`~werkzeug.datastructures.ImmutableMultiDict` is "
"returned from this function.  This can be changed by setting "
":attr:`parameter_storage_class` to a different type.  This might be "
"necessary if the order of the form data is important."
msgstr ""

#: flask.Request.authorization:1 of
msgid "The `Authorization` object in parsed form."
msgstr ""

#: flask.Request.base_url:1 of
msgid "Like :attr:`url` but without the query string."
msgstr ""

#: flask.Request.blueprint:1 of
msgid "The registered name of the current blueprint."
msgstr ""

#: flask.Request.blueprint:3 of
msgid ""
"This will be ``None`` if the endpoint is not part of a blueprint, or if "
"URL matching failed or has not been performed yet."
msgstr ""

#: flask.Request.blueprint:7 of
msgid ""
"This does not necessarily match the name the blueprint was created with. "
"It may have been nested, or registered with a different name."
msgstr ""

#: flask.Request.blueprints:1 of
msgid ""
"The registered names of the current blueprint upwards through parent "
"blueprints."
msgstr ""

#: flask.Request.blueprints:4 of
msgid ""
"This will be an empty list if there is no current blueprint, or if URL "
"matching failed."
msgstr ""

#: flask.Request.cache_control:1 of
msgid ""
"A :class:`~werkzeug.datastructures.RequestCacheControl` object for the "
"incoming cache control headers."
msgstr ""

#: of werkzeug.wrappers.request.Request.close:1
msgid ""
"Closes associated resources of this request object.  This closes all file"
" handles explicitly.  You can also use the request object in a with "
"statement which will automatically close it."
msgstr ""

#: ../../docstring flask.Request.content_encoding:1
#: flask.Response.content_encoding:1 of
msgid ""
"The Content-Encoding entity-header field is used as a modifier to the "
"media-type. When present, its value indicates what additional content "
"codings have been applied to the entity-body, and thus what decoding "
"mechanisms must be applied in order to obtain the media-type referenced "
"by the Content-Type header field."
msgstr ""

#: flask.Request.content_length:1 of
msgid ""
"The Content-Length entity-header field indicates the size of the entity-"
"body in bytes or, in the case of the HEAD method, the size of the entity-"
"body that would have been sent had the request been a GET."
msgstr ""

#: ../../docstring flask.Request.content_md5:1 flask.Response.content_md5:1 of
msgid ""
"The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 "
"digest of the entity-body for the purpose of providing an end-to-end "
"message integrity check (MIC) of the entity-body. (Note: a MIC is good "
"for detecting accidental modification of the entity-body in transit, but "
"is not proof against malicious attacks.)"
msgstr ""

#: ../../docstring flask.Request.content_type:1 flask.Response.content_type:1
#: of
msgid ""
"The Content-Type entity-header field indicates the media type of the "
"entity-body sent to the recipient or, in the case of the HEAD method, the"
" media type that would have been sent had the request been a GET."
msgstr ""

#: flask.Request.cookies:1 of
msgid ""
"A :class:`dict` with the contents of all cookies transmitted with the "
"request."
msgstr ""

#: flask.Request.data:1 of
msgid ""
"Contains the incoming request data as string in case it came with a "
"mimetype Werkzeug does not handle."
msgstr ""

#: ../../docstring flask.Request.date:1 flask.Response.date:1 of
msgid ""
"The Date general-header field represents the date and time at which the "
"message was originated, having the same semantics as orig-date in RFC "
"822."
msgstr ""

#: ../../docstring flask.Request.date:5 flask.Request.if_modified_since:3
#: flask.Request.if_unmodified_since:3 flask.Response.date:5
#: flask.Response.expires:5 flask.Response.last_modified:5
#: flask.Response.retry_after:7 of
msgid "The datetime object is timezone-aware."
msgstr ""

#: flask.Request.endpoint:1 of
msgid "The endpoint that matched the request URL."
msgstr ""

#: flask.Request.endpoint:3 of
msgid "This will be ``None`` if matching failed or has not been performed yet."
msgstr ""

#: flask.Request.endpoint:6 of
msgid ""
"This in combination with :attr:`view_args` can be used to reconstruct the"
" same URL or a modified URL."
msgstr ""

#: ../../docstring flask.Request.environ:1 of
msgid ""
"The WSGI environment containing HTTP headers and information from the "
"WSGI server."
msgstr ""

#: flask.Request.files:1 of
msgid ""
":class:`~werkzeug.datastructures.MultiDict` object containing all "
"uploaded files.  Each key in :attr:`files` is the name from the ``<input "
"type=\"file\" name=\"\">``.  Each value in :attr:`files` is a Werkzeug "
":class:`~werkzeug.datastructures.FileStorage` object."
msgstr ""

#: flask.Request.files:6 of
msgid ""
"It basically behaves like a standard file object you know from Python, "
"with the difference that it also has a "
":meth:`~werkzeug.datastructures.FileStorage.save` function that can store"
" the file on the filesystem."
msgstr ""

#: flask.Request.files:11 of
msgid ""
"Note that :attr:`files` will only contain data if the request method was "
"POST, PUT or PATCH and the ``<form>`` that posted to the request had "
"``enctype=\"multipart/form-data\"``.  It will be empty otherwise."
msgstr ""

#: flask.Request.files:15 of
msgid ""
"See the :class:`~werkzeug.datastructures.MultiDict` / "
":class:`~werkzeug.datastructures.FileStorage` documentation for more "
"details about the used data structure."
msgstr ""

#: flask.Request.form:1 of
msgid ""
"The form parameters.  By default an "
":class:`~werkzeug.datastructures.ImmutableMultiDict` is returned from "
"this function.  This can be changed by setting "
":attr:`parameter_storage_class` to a different type.  This might be "
"necessary if the order of the form data is important."
msgstr ""

#: flask.Request.form:7 of
msgid ""
"Please keep in mind that file uploads will not end up here, but instead "
"in the :attr:`files` attribute."
msgstr ""

#: flask.Request.form:12 of
msgid ""
"Previous to Werkzeug 0.9 this would only contain form data for POST and "
"PUT requests."
msgstr ""

#: of werkzeug.wrappers.request.Request.from_values:1
msgid ""
"Create a new request object based on the values provided.  If environ is "
"given missing values are filled from there.  This method is useful for "
"small scripts when you need to simulate a request from an URL. Do not use"
" this method for unittesting, there is a full featured client object "
"(:class:`Client`) that allows to create multipart requests, support for "
"cookies etc."
msgstr ""

#: of werkzeug.wrappers.request.Request.from_values:8
msgid ""
"This accepts the same options as the "
":class:`~werkzeug.test.EnvironBuilder`."
msgstr ""

#: of werkzeug.wrappers.request.Request.from_values:11
msgid ""
"This method now accepts the same arguments as "
":class:`~werkzeug.test.EnvironBuilder`.  Because of this the `environ` "
"parameter is now called `environ_overrides`."
msgstr ""

#: of werkzeug.wrappers.request.Request.from_values:16
msgid "request object"
msgstr ""

#: flask.Request.full_path:1 of
msgid "Requested path, including the query string."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_data:1
msgid ""
"This reads the buffered incoming data from the client into one bytes "
"object.  By default this is cached but that behavior can be changed by "
"setting `cache` to `False`."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_data:5
msgid ""
"Usually it's a bad idea to call this method without checking the content "
"length first as a client could send dozens of megabytes or more to cause "
"memory problems on the server."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_data:9
msgid ""
"Note that if the form data was already parsed this method will not return"
" anything as form data parsing does not cache the data like this method "
"does.  To implicitly invoke form data parsing function set "
"`parse_form_data` to `True`.  When this is done the return value of this "
"method will be an empty string if the form parser handles the data.  This"
" generally is not necessary as if the whole data is cached (which is the "
"default) the form parser will used the cached data to parse the form "
"data.  Please be generally aware of checking the content length first in "
"any case before calling this method to avoid exhausting server memory."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_data:20
#: werkzeug.wrappers.response.Response.get_data:8
msgid "If `as_text` is set to `True` the return value will be a decoded string."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_json:1
msgid "Parse :attr:`data` as JSON."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_json:3
#: werkzeug.wrappers.response.Response.get_json:3
msgid ""
"If the mimetype does not indicate JSON (:mimetype:`application/json`, see"
" :meth:`is_json`), this returns ``None``."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_json:7
msgid ""
"If parsing fails, :meth:`on_json_loading_failed` is called and its return"
" value is used as the return value."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_json:10
#: werkzeug.wrappers.response.Response.get_json:9
msgid "Ignore the mimetype and always try to parse JSON."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_json:11
#: werkzeug.wrappers.response.Response.get_json:10
msgid "Silence parsing errors and return ``None`` instead."
msgstr ""

#: of werkzeug.wrappers.request.Request.get_json:13
msgid "Store the parsed JSON to return for subsequent calls."
msgstr ""

#: ../../docstring flask.Request.headers:1 of
msgid "The headers received with the request."
msgstr ""

#: flask.Request.host:1 of
msgid ""
"The host name the request was made to, including the port if it's non-"
"standard. Validated with :attr:`trusted_hosts`."
msgstr ""

#: flask.Request.host_url:1 of
msgid "The request URL scheme and host only."
msgstr ""

#: flask.Request.if_match:1 of
msgid "An object containing all the etags in the `If-Match` header."
msgstr ""

#: flask.Request.if_match:3 flask.Request.if_none_match:3 of
msgid ":class:`~werkzeug.datastructures.ETags`"
msgstr ""

#: flask.Request.if_modified_since:1 of
msgid "The parsed `If-Modified-Since` header as a datetime object."
msgstr ""

#: flask.Request.if_none_match:1 of
msgid "An object containing all the etags in the `If-None-Match` header."
msgstr ""

#: flask.Request.if_range:1 of
msgid "The parsed ``If-Range`` header."
msgstr ""

#: flask.Request.if_range:3 of
msgid "``IfRange.date`` is timezone-aware."
msgstr ""

#: flask.Request.if_unmodified_since:1 of
msgid "The parsed `If-Unmodified-Since` header as a datetime object."
msgstr ""

#: ../../docstring flask.Request.input_stream:1 of
msgid "The WSGI input stream."
msgstr ""

#: ../../docstring flask.Request.input_stream:3 of
msgid ""
"In general it's a bad idea to use this one because you can easily read "
"past the boundary.  Use the :attr:`stream` instead."
msgstr ""

#: flask.Request.is_json:1 flask.Response.is_json:1 of
msgid ""
"Check if the mimetype indicates JSON data, either "
":mimetype:`application/json` or :mimetype:`application/*+json`."
msgstr ""

#: ../../docstring flask.Request.is_multiprocess:1 of
msgid ""
"boolean that is `True` if the application is served by a WSGI server that"
" spawns multiple processes."
msgstr ""

#: ../../docstring flask.Request.is_multithread:1 of
msgid ""
"boolean that is `True` if the application is served by a multithreaded "
"WSGI server."
msgstr ""

#: ../../docstring flask.Request.is_run_once:1 of
msgid ""
"boolean that is `True` if the application will be executed only once in a"
" process lifetime.  This is the case for CGI for example, but it's not "
"guaranteed that the execution only happens one time."
msgstr ""

#: flask.Request.is_secure:1 of
msgid "``True`` if the request was made with a secure protocol (HTTPS or WSS)."
msgstr ""

#: flask.Request.json:1 flask.Response.json:1 of
msgid ""
"The parsed JSON data if :attr:`mimetype` indicates JSON "
"(:mimetype:`application/json`, see :meth:`is_json`)."
msgstr ""

#: flask.Request.json:4 flask.Response.json:4 of
msgid "Calls :meth:`get_json` with default arguments."
msgstr ""

#: of werkzeug.wrappers.request.Request.make_form_data_parser:1
msgid ""
"Creates the form data parser. Instantiates the "
":attr:`form_data_parser_class` with some parameters."
msgstr ""

#: flask.Request.max_content_length:1 of
msgid "Read-only view of the ``MAX_CONTENT_LENGTH`` config key."
msgstr ""

#: ../../docstring flask.Request.max_forwards:1 of
msgid ""
"The Max-Forwards request-header field provides a mechanism with the TRACE"
" and OPTIONS methods to limit the number of proxies or gateways that can "
"forward the request to the next inbound server."
msgstr ""

#: ../../docstring flask.Request.method:1 of
msgid "The method the request was made with, such as ``GET``."
msgstr ""

#: flask.Request.mimetype:1 of
msgid ""
"Like :attr:`content_type`, but without parameters (eg, without charset, "
"type etc.) and always lowercase.  For example if the content type is "
"``text/HTML; charset=utf-8`` the mimetype would be ``'text/html'``."
msgstr ""

#: flask.Request.mimetype_params:1 of
msgid ""
"The mimetype parameters as dict.  For example if the content type is "
"``text/html; charset=utf-8`` the params would be ``{'charset': "
"'utf-8'}``."
msgstr ""

#: flask.wrappers.Request.on_json_loading_failed:1 of
msgid ""
"Called if :meth:`get_json` parsing fails and isn't silenced. If this "
"method returns a value, it is used as the return value for "
":meth:`get_json`. The default implementation raises "
":exc:`~werkzeug.exceptions.BadRequest`."
msgstr ""

#: ../../docstring flask.Request.origin:1 of
msgid ""
"The host that the request originated from. Set "
":attr:`~CORSResponseMixin.access_control_allow_origin` on the response to"
" indicate which origins are allowed."
msgstr ""

#: ../../docstring flask.Request.path:1 of
msgid ""
"The path part of the URL after :attr:`root_path`. This is the path used "
"for routing within the application."
msgstr ""

#: flask.Request.pragma:1 of
msgid ""
"The Pragma general-header field is used to include implementation-"
"specific directives that might apply to any recipient along the "
"request/response chain.  All pragma directives specify optional behavior "
"from the viewpoint of the protocol; however, some systems MAY require "
"that behavior be consistent with the directives."
msgstr ""

#: ../../docstring flask.Request.query_string:1 of
msgid ""
"The part of the URL after the \"?\". This is the raw value, use "
":attr:`args` for the parsed values."
msgstr ""

#: flask.Request.range:1 of
msgid "The parsed `Range` header."
msgstr ""

#: flask.Request.range:5 of
msgid ":class:`~werkzeug.datastructures.Range`"
msgstr ""

#: ../../docstring flask.Request.referrer:1 of
msgid ""
"The Referer[sic] request-header field allows the client to specify, for "
"the server's benefit, the address (URI) of the resource from which the "
"Request-URI was obtained (the \"referrer\", although the header field is "
"misspelled)."
msgstr ""

#: ../../docstring flask.Request.remote_addr:1 of
msgid "The address of the client sending the request."
msgstr ""

#: ../../docstring flask.Request.remote_user:1 of
msgid ""
"If the server supports user authentication, and the script is protected, "
"this attribute contains the username the user has authenticated as."
msgstr ""

#: ../../docstring flask.Request.root_path:1 of
msgid ""
"The prefix that the application is mounted under, without a trailing "
"slash. :attr:`path` comes after this."
msgstr ""

#: flask.Request.root_url:1 of
msgid ""
"The request URL scheme, host, and root path. This is the root that the "
"application is accessed from."
msgstr ""

#: ../../docstring flask.Request.routing_exception:1 of
msgid ""
"If matching the URL failed, this is the exception that will be raised / "
"was raised as part of the request handling.  This is usually a "
":exc:`~werkzeug.exceptions.NotFound` exception or something similar."
msgstr ""

#: ../../docstring flask.Request.scheme:1 of
msgid ""
"The URL scheme of the protocol the request used, such as ``https`` or "
"``wss``."
msgstr ""

#: flask.Request.script_root:1 of
msgid ""
"Alias for :attr:`self.root_path`. ``environ[\"SCRIPT_ROOT\"]`` without a "
"trailing slash."
msgstr ""

#: ../../docstring flask.Request.server:1 of
msgid ""
"The address of the server. ``(host, port)``, ``(path, None)`` for unix "
"sockets, or ``None`` if not known."
msgstr ""

#: ../../docstring flask.Request.shallow:1 of
msgid ""
"Set when creating the request object. If ``True``, reading from the "
"request body will cause a ``RuntimeException``. Useful to prevent "
"modifying the stream from middleware."
msgstr ""

#: flask.Request.stream:1 of
msgid ""
"If the incoming form data was not encoded with a known mimetype the data "
"is stored unmodified in this stream for consumption.  Most of the time it"
" is a better idea to use :attr:`data` which will give you that data as a "
"string.  The stream only returns the data once."
msgstr ""

#: flask.Request.stream:6 of
msgid ""
"Unlike :attr:`input_stream` this stream is properly guarded that you "
"can't accidentally read past the length of the input.  Werkzeug will "
"internally always refer to this stream to read data which makes it "
"possible to wrap this object with a stream that does filtering."
msgstr ""

#: flask.Request.stream:11 of
msgid ""
"This stream is now always available but might be consumed by the form "
"parser later on.  Previously the stream was only set if no parsing "
"happened."
msgstr ""

#: flask.Request.url:1 of
msgid ""
"The full request URL with the scheme, host, root path, path, and query "
"string."
msgstr ""

#: flask.Request.url_charset:1 of
msgid ""
"The charset that is assumed for URLs. Defaults to the value of "
":attr:`charset`."
msgstr ""

#: flask.Request.url_root:1 of
msgid ""
"Alias for :attr:`root_url`. The URL with scheme, host, and root path. For"
" example, ``https://example.com/app/``."
msgstr ""

#: ../../docstring flask.Request.url_rule:1 of
msgid ""
"The internal URL rule that matched the request.  This can be useful to "
"inspect which methods are allowed for the URL from a before/after handler"
" (``request.url_rule.methods``) etc. Though if the request's method was "
"invalid for the URL rule, the valid list is available in "
"``routing_exception.valid_methods`` instead (an attribute of the Werkzeug"
" exception :exc:`~werkzeug.exceptions.MethodNotAllowed`) because the "
"request was never internally bound."
msgstr ""

#: flask.Request.user_agent:1 of
msgid ""
"The user agent. Use ``user_agent.string`` to get the header value. Set "
":attr:`user_agent_class` to a subclass of "
":class:`~werkzeug.user_agent.UserAgent` to provide parsing for the other "
"properties or other extended data."
msgstr ""

#: flask.Request.user_agent:6 of
msgid ""
"The built in parser is deprecated and will be removed in Werkzeug 2.1. A "
"``UserAgent`` subclass must be set to parse data from the string."
msgstr ""

#: flask.Request.values:1 of
msgid ""
"A :class:`werkzeug.datastructures.CombinedMultiDict` that combines "
":attr:`args` and :attr:`form`."
msgstr ""

#: flask.Request.values:4 flask.Request.values:6 of
msgid "For GET requests, only ``args`` are present, not ``form``."
msgstr ""

#: ../../docstring flask.Request.view_args:1 of
msgid ""
"A dict of view arguments that matched the request.  If an exception "
"happened when matching, this will be ``None``."
msgstr ""

#: flask.Request.want_form_data_parsed:1 of
msgid ""
"``True`` if the request method carries content. By default this is true "
"if a ``Content-Type`` is sent."
msgstr ""

#: ../../api.rst:36
msgid ""
"To access incoming request data, you can use the global `request` object."
"  Flask parses incoming request data for you and gives you access to it "
"through that global object.  Internally Flask makes sure that you always "
"get the correct data for the active thread if you are in a multithreaded "
"environment."
msgstr ""

#: ../../api.rst:42 ../../api.rst:72
msgid "This is a proxy.  See :ref:`notes-on-proxies` for more information."
msgstr ""

#: ../../api.rst:44
msgid "The request object is an instance of a :class:`~flask.Request`."
msgstr ""

#: ../../api.rst:48
msgid "Response Objects"
msgstr ""

#: flask.wrappers.Response:1 of
msgid ""
"The response object that is used by default in Flask.  Works like the "
"response object from Werkzeug but is set to have an HTML mimetype by "
"default.  Quite often you don't have to create this object yourself "
"because :meth:`~flask.Flask.make_response` will take care of that for "
"you."
msgstr ""

#: flask.wrappers.Response:6 of
msgid ""
"If you want to replace the response object used you can subclass this and"
" set :attr:`~flask.Flask.response_class` to your subclass."
msgstr ""

#: flask.wrappers.Response:9 of
msgid ""
"JSON support is added to the response, like the request. This is useful "
"when testing to get the test client response data as JSON."
msgstr ""

#: flask.wrappers.Response:15 of
msgid "Added :attr:`max_cookie_size`."
msgstr ""

#: ../../docstring flask.Response.accept_ranges:1 of
msgid ""
"The `Accept-Ranges` header. Even though the name would indicate that "
"multiple values are supported, it must be one string token only."
msgstr ""

#: ../../docstring flask.Response.accept_ranges:5 of
msgid "The values ``'bytes'`` and ``'none'`` are common."
msgstr ""

#: flask.Response.access_control_allow_credentials:1 of
msgid ""
"Whether credentials can be shared by the browser to JavaScript code. As "
"part of the preflight request it indicates whether credentials can be "
"used on the cross origin request."
msgstr ""

#: ../../docstring flask.Response.access_control_allow_headers:1 of
msgid "Which headers can be sent with the cross origin request."
msgstr ""

#: ../../docstring flask.Response.access_control_allow_methods:1 of
msgid "Which methods can be used for the cross origin request."
msgstr ""

#: ../../docstring flask.Response.access_control_allow_origin:1 of
msgid "The origin or '*' for any origin that may make cross origin requests."
msgstr ""

#: ../../docstring flask.Response.access_control_expose_headers:1 of
msgid "Which headers can be shared by the browser to JavaScript code."
msgstr ""

#: ../../docstring flask.Response.access_control_max_age:1 of
msgid "The maximum age in seconds the access control settings can be cached for."
msgstr ""

#: of werkzeug.wrappers.response.Response.add_etag:1
msgid "Add an etag for the current response if there is none yet."
msgstr ""

#: of werkzeug.wrappers.response.Response.add_etag:3
msgid ""
"SHA-1 is used to generate the value. MD5 may not be available in some "
"environments."
msgstr ""

#: ../../docstring flask.Response.age:1 of
msgid ""
"The Age response-header field conveys the sender's estimate of the amount"
" of time since the response (or its revalidation) was generated at the "
"origin server."
msgstr ""

#: ../../docstring flask.Response.age:5 of
msgid ""
"Age values are non-negative decimal integers, representing time in "
"seconds."
msgstr ""

#: flask.Response.allow:1 of
msgid ""
"The Allow entity-header field lists the set of methods supported by the "
"resource identified by the Request-URI. The purpose of this field is "
"strictly to inform the recipient of valid methods associated with the "
"resource. An Allow header field MUST be present in a 405 (Method Not "
"Allowed) response."
msgstr ""

#: flask.Response.cache_control:1 of
msgid ""
"The Cache-Control general-header field is used to specify directives that"
" MUST be obeyed by all caching mechanisms along the request/response "
"chain."
msgstr ""

#: of werkzeug.wrappers.response.Response.calculate_content_length:1
msgid "Returns the content length if available or `None` otherwise."
msgstr ""

#: of werkzeug.wrappers.response.Response.call_on_close:1
msgid ""
"Adds a function to the internal list of functions that should be called "
"as part of closing down the response.  Since 0.7 this function also "
"returns the function that was passed so that this can be used as a "
"decorator."
msgstr ""

#: of werkzeug.wrappers.response.Response.close:1
msgid ""
"Close the wrapped response if possible.  You can also use the object in a"
" with statement which will automatically close it."
msgstr ""

#: of werkzeug.wrappers.response.Response.close:4
msgid "Can now be used in a with statement."
msgstr ""

#: flask.Response.content_language:1 of
msgid ""
"The Content-Language entity-header field describes the natural "
"language(s) of the intended audience for the enclosed entity. Note that "
"this might not be equivalent to all the languages used within the entity-"
"body."
msgstr ""

#: ../../docstring flask.Response.content_length:1 of
msgid ""
"The Content-Length entity-header field indicates the size of the entity-"
"body, in decimal number of OCTETs, sent to the recipient or, in the case "
"of the HEAD method, the size of the entity-body that would have been sent"
" had the request been a GET."
msgstr ""

#: ../../docstring flask.Response.content_location:1 of
msgid ""
"The Content-Location entity-header field MAY be used to supply the "
"resource location for the entity enclosed in the message when that entity"
" is accessible from a location separate from the requested resource's "
"URI."
msgstr ""

#: flask.Response.content_range:1 of
msgid ""
"The ``Content-Range`` header as a "
":class:`~werkzeug.datastructures.ContentRange` object. Available even if "
"the header is not set."
msgstr ""

#: ../../docstring flask.Response.content_security_policy:1 of
msgid ""
"The Content-Security-Policy header adds an additional layer of security "
"to help detect and mitigate certain types of attacks."
msgstr ""

#: ../../docstring flask.Response.content_security_policy_report_only:1 of
msgid ""
"The Content-Security-Policy-Report-Only header adds a csp policy that is "
"not enforced but is reported thereby helping detect certain types of "
"attacks."
msgstr ""

#: ../../docstring flask.Response.cross_origin_embedder_policy:1 of
msgid ""
"Prevents a document from loading any cross-origin resources that do not "
"explicitly grant the document permission. Values must be a member of the "
":class:`werkzeug.http.COEP` enum."
msgstr ""

#: ../../docstring flask.Response.cross_origin_opener_policy:1 of
msgid ""
"Allows control over sharing of browsing context group with cross-origin "
"documents. Values must be a member of the :class:`werkzeug.http.COOP` "
"enum."
msgstr ""

#: flask.Response.data:1 of
msgid "A descriptor that calls :meth:`get_data` and :meth:`set_data`."
msgstr ""

#: of werkzeug.sansio.response.Response.delete_cookie:1
msgid "Delete a cookie.  Fails silently if key doesn't exist."
msgstr ""

#: of werkzeug.sansio.response.Response.delete_cookie:3
msgid "the key (name) of the cookie to be deleted."
msgstr ""

#: of werkzeug.sansio.response.Response.delete_cookie:4
msgid ""
"if the cookie that should be deleted was limited to a path, the path has "
"to be defined here."
msgstr ""

#: of werkzeug.sansio.response.Response.delete_cookie:6
msgid ""
"if the cookie that should be deleted was limited to a domain, that domain"
" has to be defined here."
msgstr ""

#: of werkzeug.sansio.response.Response.delete_cookie:8
#: werkzeug.sansio.response.Response.set_cookie:19
msgid "If ``True``, the cookie will only be available via HTTPS."
msgstr ""

#: of werkzeug.sansio.response.Response.delete_cookie:10
#: werkzeug.sansio.response.Response.set_cookie:21
msgid "Disallow JavaScript access to the cookie."
msgstr ""

#: of werkzeug.sansio.response.Response.delete_cookie:11
#: werkzeug.sansio.response.Response.set_cookie:22
msgid ""
"Limit the scope of the cookie to only be attached to requests that are "
"\"same-site\"."
msgstr ""

#: ../../docstring flask.Response.direct_passthrough:1 of
msgid ""
"Pass the response body directly through as the WSGI iterable. This can be"
" used when the body is a binary file or other iterator of bytes, to skip "
"some unnecessary checks. Use :func:`~werkzeug.utils.send_file` instead of"
" setting this manually."
msgstr ""

#: ../../docstring flask.Response.expires:1 of
msgid ""
"The Expires entity-header field gives the date/time after which the "
"response is considered stale. A stale cache entry may not normally be "
"returned by a cache."
msgstr ""

#: of werkzeug.wrappers.response.Response.force_type:1
msgid ""
"Enforce that the WSGI response is a response object of the current type."
"  Werkzeug will use the :class:`Response` internally in many situations "
"like the exceptions.  If you call :meth:`get_response` on an exception "
"you will get back a regular :class:`Response` object, even if you are "
"using a custom subclass."
msgstr ""

#: of werkzeug.wrappers.response.Response.force_type:7
msgid ""
"This method can enforce a given response type, and it will also convert "
"arbitrary WSGI callables into response objects if an environ is "
"provided::"
msgstr ""

#: of werkzeug.wrappers.response.Response.force_type:18
msgid ""
"This is especially useful if you want to post-process responses in the "
"main dispatcher and use functionality provided by your subclass."
msgstr ""

#: of werkzeug.wrappers.response.Response.force_type:21
msgid "Keep in mind that this will modify response objects in place if possible!"
msgstr ""

#: of werkzeug.wrappers.response.Response.force_type:24
msgid "a response object or wsgi application."
msgstr ""

#: of werkzeug.wrappers.response.Response.force_type:25
msgid "a WSGI environment object."
msgstr ""

#: of werkzeug.wrappers.response.Response.force_type:26
#: werkzeug.wrappers.response.Response.from_app:11
msgid "a response object."
msgstr ""

#: of werkzeug.wrappers.response.Response.freeze:1
msgid "Make the response object ready to be pickled. Does the following:"
msgstr ""

#: of werkzeug.wrappers.response.Response.freeze:4
msgid ""
"Buffer the response into a list, ignoring "
":attr:`implicity_sequence_conversion` and :attr:`direct_passthrough`."
msgstr ""

#: of werkzeug.wrappers.response.Response.freeze:7
msgid "Set the ``Content-Length`` header."
msgstr ""

#: of werkzeug.wrappers.response.Response.freeze:8
msgid "Generate an ``ETag`` header if one is not already set."
msgstr ""

#: of werkzeug.wrappers.response.Response.freeze:10
msgid ""
"An ``ETag`` header is added, the ``no_etag`` parameter is deprecated and "
"will be removed in Werkzeug 2.1."
msgstr ""

#: of werkzeug.wrappers.response.Response.freeze:14
msgid "The ``Content-Length`` header is set."
msgstr ""

#: of werkzeug.wrappers.response.Response.from_app:1
msgid ""
"Create a new response object from an application output.  This works best"
" if you pass it an application that returns a generator all the time.  "
"Sometimes applications may use the `write()` callable returned by the "
"`start_response` function.  This tries to resolve such edge cases "
"automatically.  But if you don't get the expected output you should set "
"`buffered` to `True` which enforces buffering."
msgstr ""

#: of werkzeug.wrappers.response.Response.from_app:8
msgid "the WSGI application to execute."
msgstr ""

#: of werkzeug.wrappers.response.Response.from_app:9
msgid "the WSGI environment to execute against."
msgstr ""

#: of werkzeug.wrappers.response.Response.from_app:10
msgid "set to `True` to enforce buffering."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_app_iter:1
msgid ""
"Returns the application iterator for the given environ.  Depending on the"
" request method and the current status code the return value might be an "
"empty response rather than the one from the response."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_app_iter:5
msgid ""
"If the request method is `HEAD` or the status code is in a range where "
"the HTTP specification requires an empty response, an empty iterable is "
"returned."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_app_iter:11
#: werkzeug.wrappers.response.Response.get_wsgi_headers:20
#: werkzeug.wrappers.response.Response.get_wsgi_response:10
msgid "the WSGI environment of the request."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_app_iter:12
msgid "a response iterable."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_data:1
msgid ""
"The string representation of the response body.  Whenever you call this "
"property the response iterable is encoded and flattened.  This can lead "
"to unwanted behavior if you stream big data."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_data:5
msgid ""
"This behavior can be disabled by setting "
":attr:`implicit_sequence_conversion` to `False`."
msgstr ""

#: of werkzeug.sansio.response.Response.get_etag:1
msgid ""
"Return a tuple in the form ``(etag, is_weak)``.  If there is no ETag the "
"return value is ``(None, None)``."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_json:1
msgid "Parse :attr:`data` as JSON. Useful during testing."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_json:7
msgid "Unlike :meth:`Request.get_json`, the result is not cached."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_wsgi_headers:1
msgid ""
"This is automatically called right before the response is started and "
"returns headers modified for the given environment.  It returns a copy of"
" the headers from the response with some modifications applied if "
"necessary."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_wsgi_headers:6
msgid ""
"For example the location header (if present) is joined with the root URL "
"of the environment.  Also the content length is automatically set to zero"
" here for certain status codes."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_wsgi_headers:10
msgid ""
"Previously that function was called `fix_headers` and modified the "
"response object in place.  Also since 0.6, IRIs in location and content-"
"location headers are handled properly."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_wsgi_headers:15
msgid ""
"Also starting with 0.6, Werkzeug will attempt to set the content length "
"if it is able to figure it out on its own.  This is the case if all the "
"strings in the response iterable are already encoded and the iterable is "
"buffered."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_wsgi_headers:21
msgid "returns a new :class:`~werkzeug.datastructures.Headers` object."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_wsgi_response:1
msgid ""
"Returns the final WSGI response as tuple.  The first item in the tuple is"
" the application iterator, the second the status and the third the list "
"of headers.  The response returned is created specially for the given "
"environment.  For example if the request method in the WSGI environment "
"is ``'HEAD'`` the response will be empty and only the headers and status "
"code will be present."
msgstr ""

#: of werkzeug.wrappers.response.Response.get_wsgi_response:11
msgid "an ``(app_iter, status, headers)`` tuple."
msgstr ""

#: flask.Response.is_sequence:1 of
msgid ""
"If the iterator is buffered, this property will be `True`.  A response "
"object will consider an iterator to be buffered if the response attribute"
" is a list or tuple."
msgstr ""

#: flask.Response.is_streamed:1 of
msgid ""
"If the response is streamed (the response is not an iterable with a "
"length information) this property is `True`.  In this case streamed means"
" that there is no information about the number of iterations. This is "
"usually `True` if a generator is passed to the response object."
msgstr ""

#: flask.Response.is_streamed:6 of
msgid ""
"This is useful for checking before applying some sort of post filtering "
"that should not take place for streamed responses."
msgstr ""

#: of werkzeug.wrappers.response.Response.iter_encoded:1
msgid ""
"Iter the response encoded with the encoding of the response. If the "
"response object is invoked as WSGI application the return value of this "
"method is used as application iterator unless :attr:`direct_passthrough` "
"was activated."
msgstr ""

#: ../../docstring flask.Response.last_modified:1 of
msgid ""
"The Last-Modified entity-header field indicates the date and time at "
"which the origin server believes the variant was last modified."
msgstr ""

#: ../../docstring flask.Response.location:1 of
msgid ""
"The Location response-header field is used to redirect the recipient to a"
" location other than the Request-URI for completion of the request or "
"identification of a new resource."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:1
msgid ""
"Make the response conditional to the request.  This method works best if "
"an etag was defined for the response already.  The `add_etag` method can "
"be used to do that.  If called without etag just the date header is set."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:6
msgid ""
"This does nothing if the request method in the request or environ is "
"anything but GET or HEAD."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:9
msgid ""
"For optimal performance when handling range requests, it's recommended "
"that your response data object implements `seekable`, `seek` and `tell` "
"methods as described by :py:class:`io.IOBase`.  Objects returned by "
":meth:`~werkzeug.wsgi.wrap_file` automatically implement those methods."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:14
msgid ""
"It does not remove the body of the response because that's something the "
":meth:`__call__` function does for us automatically."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:17
msgid ""
"Returns self so that you can do ``return resp.make_conditional(req)`` but"
" modifies the object in-place."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:20
msgid ""
"a request object or WSGI environment to be used to make the response "
"conditional against."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:23
msgid ""
"This parameter dictates the value of `Accept-Ranges` header. If ``False``"
" (default), the header is not set. If ``True``, it will be set to "
"``\"bytes\"``. If ``None``, it will be set to ``\"none\"``. If it's a "
"string, it will use this value."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:29
msgid ""
"Will be used only in valid Range Requests. It will set `Content-Range` "
"complete length value and compute `Content-Length` real value. This "
"parameter is mandatory for successful Range Requests completion."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional
msgid "raises"
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:34
msgid ""
":class:`~werkzeug.exceptions.RequestedRangeNotSatisfiable` if `Range` "
"header could not be parsed or satisfied."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_conditional:37
msgid ""
"Range processing is skipped if length is 0 instead of raising a 416 Range"
" Not Satisfiable error."
msgstr ""

#: of werkzeug.wrappers.response.Response.make_sequence:1
msgid ""
"Converts the response iterator in a list.  By default this happens "
"automatically if required.  If `implicit_sequence_conversion` is "
"disabled, this method is not automatically called and some properties "
"might raise exceptions.  This also encodes all the items."
msgstr ""

#: flask.Response.max_cookie_size:1 of
msgid "Read-only view of the :data:`MAX_COOKIE_SIZE` config key."
msgstr ""

#: flask.Response.max_cookie_size:3 of
msgid ""
"See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in Werkzeug's "
"docs."
msgstr ""

#: flask.Response.mimetype:1 of
msgid "The mimetype (content type without charset etc.)"
msgstr ""

#: flask.Response.mimetype_params:1 of
msgid ""
"The mimetype parameters as dict. For example if the content type is "
"``text/html; charset=utf-8`` the params would be ``{'charset': "
"'utf-8'}``."
msgstr ""

#: flask.Response.retry_after:1 of
msgid ""
"The Retry-After response-header field can be used with a 503 (Service "
"Unavailable) response to indicate how long the service is expected to be "
"unavailable to the requesting client."
msgstr ""

#: flask.Response.retry_after:5 of
msgid "Time in seconds until expiration or date."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:1
msgid "Sets a cookie."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:3
msgid ""
"A warning is raised if the size of the cookie header exceeds "
":attr:`max_cookie_size`, but the header will still be set."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:6
msgid "the key (name) of the cookie to be set."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:7
msgid "the value of the cookie."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:8
msgid ""
"should be a number of seconds, or `None` (default) if the cookie should "
"last only as long as the client's browser session."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:11
msgid "should be a `datetime` object or UNIX timestamp."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:12
msgid ""
"limits the cookie to a given path, per default it will span the whole "
"domain."
msgstr ""

#: of werkzeug.sansio.response.Response.set_cookie:14
msgid ""
"if you want to set a cross-domain cookie.  For example, "
"``domain=\".example.com\"`` will set a cookie that is readable by the "
"domain ``www.example.com``, ``foo.example.com`` etc.  Otherwise, a cookie"
" will only be readable by the domain that set it."
msgstr ""

#: of werkzeug.wrappers.response.Response.set_data:1
msgid ""
"Sets a new string as response.  The value must be a string or bytes. If a"
" string is set it's encoded to the charset of the response (utf-8 by "
"default)."
msgstr ""

#: of werkzeug.sansio.response.Response.set_etag:1
msgid "Set the etag, and override the old one if there was one."
msgstr ""

#: flask.Response.status:1 of
msgid "The HTTP status code as a string."
msgstr ""

#: flask.Response.status_code:1 of
msgid "The HTTP status code as a number."
msgstr ""

#: flask.Response.stream:1 of
msgid "The response iterable as write-only stream."
msgstr ""

#: flask.Response.vary:1 of
msgid ""
"The Vary field value indicates the set of request-header fields that "
"fully determines, while the response is fresh, whether a cache is "
"permitted to use the response to reply to a subsequent request without "
"revalidation."
msgstr ""

#: flask.Response.www_authenticate:1 of
msgid "The ``WWW-Authenticate`` header in a parsed form."
msgstr ""

#: ../../api.rst:56
msgid "Sessions"
msgstr ""

#: ../../api.rst:58
msgid ""
"If you have set :attr:`Flask.secret_key` (or configured it from "
":data:`SECRET_KEY`) you can use sessions in Flask applications. A session"
" makes it possible to remember information from one request to another. "
"The way Flask does this is by using a signed cookie. The user can look at"
" the session contents, but can't modify it unless they know the secret "
"key, so make sure to set that to something complex and unguessable."
msgstr ""

#: ../../api.rst:65
msgid "To access the current session you can use the :class:`session` object:"
msgstr ""

#: ../../api.rst:69
msgid ""
"The session object works pretty much like an ordinary dict, with the "
"difference that it keeps track of modifications."
msgstr ""

#: ../../api.rst:74
msgid "The following attributes are interesting:"
msgstr ""

#: ../../api.rst:78
msgid "``True`` if the session is new, ``False`` otherwise."
msgstr ""

#: ../../api.rst:82
msgid ""
"``True`` if the session object detected a modification.  Be advised that "
"modifications on mutable structures are not picked up automatically, in "
"that situation you have to explicitly set the attribute to ``True`` "
"yourself.  Here an example::"
msgstr ""

#: ../../api.rst:95
msgid ""
"If set to ``True`` the session lives for "
":attr:`~flask.Flask.permanent_session_lifetime` seconds.  The default is "
"31 days.  If set to ``False`` (which is the default) the session will be "
"deleted when the user closes the browser."
msgstr ""

#: ../../api.rst:102
msgid "Session Interface"
msgstr ""

#: ../../api.rst:106
msgid ""
"The session interface provides a simple way to replace the session "
"implementation that Flask is using."
msgstr ""

#: flask.sessions.SessionInterface:1 of
msgid ""
"The basic interface you have to implement in order to replace the default"
" session interface which uses werkzeug's securecookie implementation.  "
"The only methods you have to implement are :meth:`open_session` and "
":meth:`save_session`, the others have useful defaults which you don't "
"need to change."
msgstr ""

#: flask.sessions.SessionInterface:7 of
msgid ""
"The session object returned by the :meth:`open_session` method has to "
"provide a dictionary like interface plus the properties and methods from "
"the :class:`SessionMixin`.  We recommend just subclassing a dict and "
"adding that mixin::"
msgstr ""

#: flask.sessions.SessionInterface:15 of
msgid ""
"If :meth:`open_session` returns ``None`` Flask will call into "
":meth:`make_null_session` to create a session that acts as replacement if"
" the session support cannot work because some requirement is not "
"fulfilled.  The default :class:`NullSession` class that is created will "
"complain that the secret key was not set."
msgstr ""

#: flask.sessions.SessionInterface:21 of
msgid ""
"To replace the session interface on an application all you have to do is "
"to assign :attr:`flask.Flask.session_interface`::"
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_domain:1 of
msgid "Returns the domain that should be set for the session cookie."
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_domain:3 of
msgid ""
"Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise falls back "
"to detecting the domain based on ``SERVER_NAME``."
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_domain:6 of
msgid ""
"Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is "
"updated to avoid re-running the logic."
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_httponly:1 of
msgid ""
"Returns True if the session cookie should be httponly.  This currently "
"just returns the value of the ``SESSION_COOKIE_HTTPONLY`` config var."
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_name:1 of
msgid "Returns the name of the session cookie."
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_name:3 of
msgid "Uses ``app.session_cookie_name`` which is set to ``SESSION_COOKIE_NAME``"
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_path:1 of
msgid ""
"Returns the path for which the cookie should be valid.  The default "
"implementation uses the value from the ``SESSION_COOKIE_PATH`` config var"
" if it's set, and falls back to ``APPLICATION_ROOT`` or uses ``/`` if "
"it's ``None``."
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_samesite:1 of
msgid ""
"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the "
"``SameSite`` attribute. This currently just returns the value of the "
":data:`SESSION_COOKIE_SAMESITE` setting."
msgstr ""

#: flask.sessions.SessionInterface.get_cookie_secure:1 of
msgid ""
"Returns True if the cookie should be secure.  This currently just returns"
" the value of the ``SESSION_COOKIE_SECURE`` setting."
msgstr ""

#: flask.sessions.SessionInterface.get_expiration_time:1 of
msgid ""
"A helper method that returns an expiration date for the session or "
"``None`` if the session is linked to the browser session.  The default "
"implementation returns now + the permanent session lifetime configured on"
" the application."
msgstr ""

#: flask.sessions.SessionInterface.is_null_session:1 of
msgid ""
"Checks if a given object is a null session.  Null sessions are not asked "
"to be saved."
msgstr ""

#: flask.sessions.SessionInterface.is_null_session:4 of
msgid ""
"This checks if the object is an instance of :attr:`null_session_class` by"
" default."
msgstr ""

#: flask.sessions.SessionInterface.make_null_session:1 of
msgid ""
"Creates a null session which acts as a replacement object if the real "
"session support could not be loaded due to a configuration error.  This "
"mainly aids the user experience because the job of the null session is to"
" still support lookup without complaining but modifications are answered "
"with a helpful error message of what failed."
msgstr ""

#: flask.sessions.SessionInterface.make_null_session:8 of
msgid "This creates an instance of :attr:`null_session_class` by default."
msgstr ""

#: flask.sessions.NullSession:1 of
msgid ""
":meth:`make_null_session` will look here for the class that should be "
"created when a null session is requested.  Likewise the "
":meth:`is_null_session` method will perform a typecheck against this "
"type."
msgstr ""

#: flask.sessions.SecureCookieSessionInterface.open_session:1
#: flask.sessions.SessionInterface.open_session:1 of
msgid ""
"This method has to be implemented and must either return ``None`` in case"
" the loading failed because of a configuration error or an instance of a "
"session object which implements a dictionary like interface + the methods"
" and attributes on :class:`SessionMixin`."
msgstr ""

#: ../../docstring flask.sessions.SessionInterface.pickle_based:1 of
msgid ""
"A flag that indicates if the session interface is pickle based. This can "
"be used by Flask extensions to make a decision in regards to how to deal "
"with the session object."
msgstr ""

#: flask.sessions.SecureCookieSessionInterface.save_session:1
#: flask.sessions.SessionInterface.save_session:1 of
msgid ""
"This is called for actual sessions returned by :meth:`open_session` at "
"the end of the request.  This is still called during a request context so"
" if you absolutely need access to the request you can do that."
msgstr ""

#: flask.sessions.SessionInterface.should_set_cookie:1 of
msgid ""
"Used by session backends to determine if a ``Set-Cookie`` header should "
"be set for this session cookie for this response. If the session has been"
" modified, the cookie is set. If the session is permanent and the "
"``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is always "
"set."
msgstr ""

#: flask.sessions.SessionInterface.should_set_cookie:7 of
msgid "This check is usually skipped if the session was deleted."
msgstr ""

#: flask.sessions.SecureCookieSessionInterface:1 of
msgid ""
"The default session interface that stores sessions in signed cookies "
"through the :mod:`itsdangerous` module."
msgstr ""

#: _hashlib.openssl_sha1:1 of
msgid "the hash function to use for the signature.  The default is sha1"
msgstr ""

#: ../../docstring flask.sessions.SecureCookieSessionInterface.key_derivation:1
#: of
msgid ""
"the name of the itsdangerous supported key derivation.  The default is "
"hmac."
msgstr ""

#: ../../docstring flask.sessions.SecureCookieSessionInterface.salt:1 of
msgid ""
"the salt that should be applied on top of the secret key for the signing "
"of cookie based sessions."
msgstr ""

#: ../../docstring flask.sessions.SecureCookieSessionInterface.serializer:1 of
msgid ""
"A python serializer for the payload.  The default is a compact JSON "
"derived serializer with support for some extra Python types such as "
"datetime objects or tuples."
msgstr ""

#: flask.sessions.SecureCookieSession:1 of
msgid "Base class for sessions based on signed cookies."
msgstr ""

#: flask.sessions.SecureCookieSession:3 of
msgid ""
"This session backend will set the :attr:`modified` and :attr:`accessed` "
"attributes. It cannot reliably track whether a session is new (vs. "
"empty), so :attr:`new` remains hard coded to ``False``."
msgstr ""

#: ../../docstring flask.sessions.SecureCookieSession.accessed:1 of
msgid ""
"header, which allows caching proxies to cache different pages for "
"different users."
msgstr ""

#: flask.sessions.SecureCookieSession.get:1
#: flask.sessions.SecureCookieSession.setdefault:3 of
msgid "Return the value for key if key is in the dictionary, else default."
msgstr ""

#: ../../docstring flask.sessions.SecureCookieSession.modified:1 of
msgid ""
"When data is changed, this is set to ``True``. Only the session "
"dictionary itself is tracked; if the session contains mutable data (for "
"example a nested dict) then this must be set to ``True`` manually when "
"modifying that data. The session cookie will only be written to the "
"response if this is ``True``."
msgstr ""

#: flask.sessions.SecureCookieSession.setdefault:1 of
msgid "Insert key with a value of default if key is not in the dictionary."
msgstr ""

#: flask.sessions.NullSession:1 of
msgid ""
"Class used to generate nicer error messages if sessions are not "
"available.  Will still allow read-only access to the empty session but "
"fail on setting."
msgstr ""

#: flask.sessions.SessionMixin:1 of
msgid "Expands a basic dictionary with session attributes."
msgstr ""

#: ../../docstring flask.sessions.SessionMixin.accessed:1 of
msgid ""
"Some implementations can detect when session data is read or written and "
"set this when that happens. The mixin default is hard coded to ``True``."
msgstr ""

#: ../../docstring flask.sessions.SessionMixin.modified:1 of
msgid ""
"Some implementations can detect changes to the session and set this when "
"that happens. The mixin default is hard coded to ``True``."
msgstr ""

#: flask.sessions.SessionMixin.permanent:1 of
msgid "This reflects the ``'_permanent'`` key in the dict."
msgstr ""

#: ../../api.rst:126
msgid "Notice"
msgstr ""

#: ../../api.rst:128
msgid ""
"The ``PERMANENT_SESSION_LIFETIME`` config key can also be an integer "
"starting with Flask 0.8.  Either catch this down yourself or use the "
":attr:`~flask.Flask.permanent_session_lifetime` attribute on the app "
"which converts the result to an integer automatically."
msgstr ""

#: ../../api.rst:135
msgid "Test Client"
msgstr ""

#: flask.testing.FlaskClient:1 of
msgid ""
"Works like a regular Werkzeug test client but has some knowledge about "
"how Flask works to defer the cleanup of the request context stack to the "
"end of a ``with`` body when used in a ``with`` statement.  For general "
"information about how to use this class refer to "
":class:`werkzeug.test.Client`."
msgstr ""

#: flask.testing.FlaskClient:7 of
msgid ""
"`app.test_client()` includes preset default environment, which can be set"
" after instantiation of the `app.test_client()` object in "
"`client.environ_base`."
msgstr ""

#: flask.testing.FlaskClient:12 of
msgid "Basic usage is outlined in the :doc:`/testing` chapter."
msgstr ""

#: flask.testing.FlaskClient.open:1 of
msgid ""
"Generate an environ dict from the given arguments, make a request to the "
"application using it, and return the response."
msgstr ""

#: flask.testing.FlaskClient.open:4 of
msgid ""
"Passed to :class:`EnvironBuilder` to create the environ for the request. "
"If a single arg is passed, it can be an existing :class:`EnvironBuilder` "
"or an environ dict."
msgstr ""

#: flask.testing.FlaskClient.open:7 of
msgid ""
"Convert the iterator returned by the app into a list. If the iterator has"
" a ``close()`` method, it is called automatically."
msgstr ""

#: flask.testing.FlaskClient.open:10 of
msgid ""
"Make additional requests to follow HTTP redirects until a non-redirect "
"status is returned. :attr:`TestResponse.history` lists the intermediate "
"responses."
msgstr ""

#: flask.testing.FlaskClient.open:15 of
msgid ""
"``as_tuple`` is deprecated and will be removed in Werkzeug 2.1. Use "
":attr:`TestResponse.request` and ``request.environ`` instead."
msgstr ""

#: flask.testing.FlaskClient.open:20 of
msgid ""
"The request input stream is closed when calling ``response.close()``. "
"Input streams for redirects are automatically closed."
msgstr ""

#: flask.testing.FlaskClient.open:25 of
msgid ""
"If a dict is provided as file in the dict for the ``data`` parameter the "
"content type has to be called ``content_type`` instead of ``mimetype``. "
"This change was made for consistency with :class:`werkzeug.FileWrapper`."
msgstr ""

#: flask.testing.FlaskClient.open:31 of
msgid "Added the ``follow_redirects`` parameter."
msgstr ""

#: flask.testing.FlaskClient.session_transaction:1 of
msgid ""
"When used in combination with a ``with`` statement this opens a session "
"transaction.  This can be used to modify the session that the test client"
" uses.  Once the ``with`` block is left the session is stored back."
msgstr ""

#: flask.testing.FlaskClient.session_transaction:11 of
msgid ""
"Internally this is implemented by going through a temporary test request "
"context and since session handling could depend on request variables this"
" function accepts the same arguments as "
":meth:`~flask.Flask.test_request_context` which are directly passed "
"through."
msgstr ""

#: ../../api.rst:144
msgid "Test CLI Runner"
msgstr ""

#: flask.testing.FlaskCliRunner:1 of
msgid ""
"A :class:`~click.testing.CliRunner` for testing a Flask app's CLI "
"commands. Typically created using :meth:`~flask.Flask.test_cli_runner`. "
"See :ref:`testing-cli`."
msgstr ""

#: flask.testing.FlaskCliRunner.invoke:1 of
msgid ""
"Invokes a CLI command in an isolated environment. See "
":meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for full method"
" documentation. See :ref:`testing-cli` for examples."
msgstr ""

#: flask.testing.FlaskCliRunner.invoke:5 of
msgid ""
"If the ``obj`` argument is not given, passes an instance of "
":class:`~flask.cli.ScriptInfo` that knows how to load the Flask app being"
" tested."
msgstr ""

#: flask.testing.FlaskCliRunner.invoke:9 of
msgid ""
"Command object to invoke. Default is the app's "
":attr:`~flask.app.Flask.cli` group."
msgstr ""

#: flask.testing.FlaskCliRunner.invoke:11 of
msgid "List of strings to invoke the command with."
msgstr ""

#: flask.testing.FlaskCliRunner.invoke:13 of
msgid "a :class:`~click.testing.Result` object."
msgstr ""

#: ../../api.rst:153
msgid "Application Globals"
msgstr ""

#: ../../api.rst:157
msgid ""
"To share data that is valid for one request only from one function to "
"another, a global variable is not good enough because it would break in "
"threaded environments.  Flask provides you with a special object that "
"ensures it is only valid for the active request and that will return "
"different values for each request.  In a nutshell: it does the right "
"thing, like it does for :class:`request` and :class:`session`."
msgstr ""

#: ../../api.rst:166
msgid ""
"A namespace object that can store data during an :doc:`application "
"context </appcontext>`. This is an instance of "
":attr:`Flask.app_ctx_globals_class`, which defaults to "
":class:`ctx._AppCtxGlobals`."
msgstr ""

#: ../../api.rst:171
msgid ""
"This is a good place to store resources during a request. During testing,"
" you can use the :ref:`faking-resources` pattern to pre-configure such "
"resources."
msgstr ""

#: ../../api.rst:175 ../../api.rst:199
msgid "This is a proxy. See :ref:`notes-on-proxies` for more information."
msgstr ""

#: ../../api.rst:177
msgid "Bound to the application context instead of the request context."
msgstr ""

#: flask.ctx._AppCtxGlobals:1 of
msgid ""
"A plain object. Used as a namespace for storing data during an "
"application context."
msgstr ""

#: flask.ctx._AppCtxGlobals:4 of
msgid ""
"Creating an app context automatically creates this object, which is made "
"available as the :data:`g` proxy."
msgstr ""

#: flask.ctx._AppCtxGlobals:9 of
msgid "Check whether an attribute is present."
msgstr ""

#: flask.ctx._AppCtxGlobals:15 of
msgid "Return an iterator over the attribute names."
msgstr ""

#: flask.ctx._AppCtxGlobals.get:1 of
msgid "Get an attribute by name, or a default value. Like :meth:`dict.get`."
msgstr ""

#: flask.ctx._AppCtxGlobals.get:4 flask.ctx._AppCtxGlobals.setdefault:4 of
msgid "Name of attribute to get."
msgstr ""

#: flask.ctx._AppCtxGlobals.get:5 of
msgid "Value to return if the attribute is not present."
msgstr ""

#: flask.ctx._AppCtxGlobals.pop:1 of
msgid "Get and remove an attribute by name. Like :meth:`dict.pop`."
msgstr ""

#: flask.ctx._AppCtxGlobals.pop:3 of
msgid "Name of attribute to pop."
msgstr ""

#: flask.ctx._AppCtxGlobals.pop:4 of
msgid ""
"Value to return if the attribute is not present, instead of raising a "
"``KeyError``."
msgstr ""

#: flask.ctx._AppCtxGlobals.setdefault:1 of
msgid ""
"Get the value of an attribute if it is present, otherwise set and return "
"a default value. Like :meth:`dict.setdefault`."
msgstr ""

#: flask.ctx._AppCtxGlobals.setdefault:5 of
msgid "Value to set and return if the attribute is not present."
msgstr ""

#: ../../api.rst:185
msgid "Useful Functions and Classes"
msgstr ""

#: ../../api.rst:189
msgid ""
"A proxy to the application handling the current request. This is useful "
"to access the application without needing to import it, or if it can't be"
" imported, such as when using the application factory pattern or in "
"blueprints and extensions."
msgstr ""

#: ../../api.rst:194
msgid ""
"This is only available when an :doc:`application context </appcontext>` "
"is pushed. This happens automatically during requests and CLI commands. "
"It can be controlled manually with :meth:`~flask.Flask.app_context`."
msgstr ""

#: flask.ctx.has_request_context:1 of
msgid ""
"If you have code that wants to test if a request context is there or not "
"this function can be used.  For instance, you may want to take advantage "
"of request information if the request object is available, but fail "
"silently if it is unavailable."
msgstr ""

#: flask.ctx.has_request_context:16 of
msgid ""
"Alternatively you can also just test any of the context bound objects "
"(such as :class:`request` or :class:`g`) for truthness::"
msgstr ""

#: flask.ctx.copy_current_request_context:1 of
msgid ""
"A helper function that decorates a function to retain the current request"
" context.  This is useful when working with greenlets.  The moment the "
"function is decorated a copy of the request context is created and then "
"pushed when the function is called.  The current session is also included"
" in the copied request context."
msgstr ""

#: flask.ctx.has_app_context:1 of
msgid ""
"Works like :func:`has_request_context` but for the application context.  "
"You can also just do a boolean check on the :data:`current_app` object "
"instead."
msgstr ""

#: flask.helpers.url_for:1 of
msgid "Generates a URL to the given endpoint with the method provided."
msgstr ""

#: flask.helpers.url_for:3 of
msgid ""
"Variable arguments that are unknown to the target endpoint are appended "
"to the generated URL as query arguments.  If the value of a query "
"argument is ``None``, the whole pair is skipped.  In case blueprints are "
"active you can shortcut references to the same blueprint by prefixing the"
" local endpoint with a dot (``.``)."
msgstr ""

#: flask.helpers.url_for:9 of
msgid "This will reference the index function local to the current blueprint::"
msgstr ""

#: flask.helpers.url_for:13 of
msgid "See :ref:`url-building`."
msgstr ""

#: flask.helpers.url_for:15 of
msgid ""
"Configuration values ``APPLICATION_ROOT`` and ``SERVER_NAME`` are only "
"used when generating URLs outside of a request context."
msgstr ""

#: flask.helpers.url_for:18 of
msgid ""
"To integrate applications, :class:`Flask` has a hook to intercept URL "
"build errors through :attr:`Flask.url_build_error_handlers`.  The "
"`url_for` function results in a :exc:`~werkzeug.routing.BuildError` when "
"the current app does not have a URL for the given endpoint and values.  "
"When it does, the :data:`~flask.current_app` calls its "
":attr:`~Flask.url_build_error_handlers` if it is not ``None``, which can "
"return a string to use as the result of `url_for` (instead of `url_for`'s"
" default to raise the :exc:`~werkzeug.routing.BuildError` exception) or "
"re-raise the exception. An example::"
msgstr ""

#: flask.helpers.url_for:47 of
msgid ""
"Here, `error` is the instance of :exc:`~werkzeug.routing.BuildError`, and"
" `endpoint` and `values` are the arguments passed into `url_for`.  Note "
"that this is for building URLs outside the current application, and not "
"for handling 404 NotFound errors."
msgstr ""

#: flask.helpers.url_for:52 of
msgid "The `_scheme` parameter was added."
msgstr ""

#: flask.helpers.url_for:55 of
msgid "The `_anchor` and `_method` parameters were added."
msgstr ""

#: flask.helpers.url_for:58 of
msgid ""
"Calls :meth:`Flask.handle_build_error` on "
":exc:`~werkzeug.routing.BuildError`."
msgstr ""

#: flask.helpers.url_for:62 of
msgid "the endpoint of the URL (name of the function)"
msgstr ""

#: flask.helpers.url_for:63 of
msgid "the variable arguments of the URL rule"
msgstr ""

#: flask.helpers.url_for:64 of
msgid ""
"if set to ``True``, an absolute URL is generated. Server address can be "
"changed via ``SERVER_NAME`` configuration variable which falls back to "
"the `Host` header, then to the IP and port of the request."
msgstr ""

#: flask.helpers.url_for:67 of
msgid ""
"a string specifying the desired URL scheme. The `_external` parameter "
"must be set to ``True`` or a :exc:`ValueError` is raised. The default "
"behavior uses the same scheme as the current request, or "
":data:`PREFERRED_URL_SCHEME` if no request context is available. This "
"also can be set to an empty string to build protocol-relative URLs."
msgstr ""

#: flask.helpers.url_for:73 of
msgid "if provided this is added as anchor to the URL."
msgstr ""

#: flask.helpers.url_for:74 of
msgid "if provided this explicitly specifies an HTTP method."
msgstr ""

#: of werkzeug.exceptions.abort:1
msgid ""
"Raises an :py:exc:`HTTPException` for the given status code or WSGI "
"application."
msgstr ""

#: of werkzeug.exceptions.abort:4
msgid ""
"If a status code is given, it will be looked up in the list of exceptions"
" and will raise that exception.  If passed a WSGI application, it will "
"wrap it in a proxy WSGI exception and raise that::"
msgstr ""

#: of werkzeug.utils.redirect:1
msgid ""
"Returns a response object (a WSGI application) that, if called, redirects"
" the client to the target location. Supported codes are 301, 302, 303, "
"305, 307, and 308. 300 is not supported because it's not a real redirect "
"and 304 because it's the answer for a request with a request with defined"
" If-Modified-Since headers."
msgstr ""

#: of werkzeug.utils.redirect:11
msgid "The class used for the Response object can now be passed in."
msgstr ""

#: of werkzeug.utils.redirect:7
msgid ""
"The location can now be a unicode string that is encoded using the "
":func:`iri_to_uri` function."
msgstr ""

#: of werkzeug.utils.redirect:14
msgid "the location the response should redirect to."
msgstr ""

#: of werkzeug.utils.redirect:15
msgid "the redirect status code. defaults to 302."
msgstr ""

#: of werkzeug.utils.redirect:16
msgid ""
"a Response class to use when instantiating a response. The default is "
":class:`werkzeug.wrappers.Response` if unspecified."
msgstr ""

#: flask.helpers.make_response:1 of
msgid ""
"Sometimes it is necessary to set additional headers in a view.  Because "
"views do not have to return response objects but can return a value that "
"is converted into a response object by Flask itself, it becomes tricky to"
" add headers to it.  This function can be called instead of using a "
"return and you will get a response object which you can use to attach "
"headers."
msgstr ""

#: flask.helpers.make_response:7 of
msgid "If view looked like this and you want to add a new header::"
msgstr ""

#: flask.helpers.make_response:12 of
msgid "You can now do something like this::"
msgstr ""

#: flask.helpers.make_response:19 of
msgid ""
"This function accepts the very same arguments you can return from a view "
"function.  This for example creates a response with a 404 error code::"
msgstr ""

#: flask.helpers.make_response:25 of
msgid ""
"The other use case of this function is to force the return value of a "
"view function into a response which is helpful with view decorators::"
msgstr ""

#: flask.helpers.make_response:32 of
msgid "Internally this function does the following things:"
msgstr ""

#: flask.helpers.make_response:34 of
msgid "if no arguments are passed, it creates a new response argument"
msgstr ""

#: flask.helpers.make_response:35 of
msgid ""
"if one argument is passed, :meth:`flask.Flask.make_response` is invoked "
"with it."
msgstr ""

#: flask.helpers.make_response:37 of
msgid ""
"if more than one argument is passed, the arguments are passed to the "
":meth:`flask.Flask.make_response` function as tuple."
msgstr ""

#: flask.ctx.after_this_request:1 of
msgid ""
"Executes a function after this request.  This is useful to modify "
"response objects.  The function is passed the response object and has to "
"return the same or a new one."
msgstr ""

#: flask.ctx.after_this_request:15 of
msgid ""
"This is more useful if a function other than the view function wants to "
"modify a response.  For instance think of a decorator that wants to add "
"some headers without converting the return value into a response object."
msgstr ""

#: flask.helpers.send_file:1 of
msgid "Send the contents of a file to the client."
msgstr ""

#: flask.helpers.send_file:3 of
msgid ""
"The first argument can be a file path or a file-like object. Paths are "
"preferred in most cases because Werkzeug can manage the file and get "
"extra information from the path. Passing a file-like object requires that"
" the file is opened in binary mode, and is mostly useful when building a "
"file in memory with :class:`io.BytesIO`."
msgstr ""

#: flask.helpers.send_file:9 of
msgid ""
"Never pass file paths provided by a user. The path is assumed to be "
"trusted, so a user could craft a path to access a file you didn't intend."
" Use :func:`send_from_directory` to safely serve user-requested paths "
"from within a directory."
msgstr ""

#: flask.helpers.send_file:14 of
msgid ""
"If the WSGI server sets a ``file_wrapper`` in ``environ``, it is used, "
"otherwise Werkzeug's built-in wrapper is used. Alternatively, if the HTTP"
" server supports ``X-Sendfile``, configuring Flask with ``USE_X_SENDFILE "
"= True`` will tell the server to send the given path, which is much more "
"efficient than reading it in Python."
msgstr ""

#: flask.helpers.send_file:20 of
msgid ""
"The path to the file to send, relative to the current working directory "
"if a relative path is given. Alternatively, a file-like object opened in "
"binary mode. Make sure the file pointer is seeked to the start of the "
"data."
msgstr ""

#: flask.helpers.send_file:24 of
msgid ""
"The MIME type to send for the file. If not provided, it will try to "
"detect it from the file name."
msgstr ""

#: flask.helpers.send_file:26 of
msgid ""
"Indicate to a browser that it should offer to save the file instead of "
"displaying it."
msgstr ""

#: flask.helpers.send_file:28 of
msgid ""
"The default name browsers will use when saving the file. Defaults to the "
"passed file name."
msgstr ""

#: flask.helpers.send_file:30 of
msgid ""
"Enable conditional and range responses based on request headers. Requires"
" passing a file path and ``environ``."
msgstr ""

#: flask.helpers.send_file:32 of
msgid ""
"Calculate an ETag for the file, which requires passing a file path. Can "
"also be a string to use instead."
msgstr ""

#: flask.helpers.send_file:34 of
msgid ""
"The last modified time to send for the file, in seconds. If not provided,"
" it will try to detect it from the file path."
msgstr ""

#: flask.helpers.send_file:37 of
msgid ""
"How long the client should cache the file, in seconds. If set, ``Cache-"
"Control`` will be ``public``, otherwise it will be ``no-cache`` to prefer"
" conditional caching."
msgstr ""

#: flask.helpers.send_file:41 of
msgid ""
"``download_name`` replaces the ``attachment_filename`` parameter. If "
"``as_attachment=False``, it is passed with ``Content-Disposition: "
"inline`` instead."
msgstr ""

#: flask.helpers.send_file:46 of
msgid ""
"``max_age`` replaces the ``cache_timeout`` parameter. ``conditional`` is "
"enabled and ``max_age`` is not set by default."
msgstr ""

#: flask.helpers.send_file:51 of
msgid ""
"``etag`` replaces the ``add_etags`` parameter. It can be a string to use "
"instead of generating one."
msgstr ""

#: flask.helpers.send_file:55 of
msgid ""
"Passing a file-like object that inherits from :class:`~io.TextIOBase` "
"will raise a :exc:`ValueError` rather than sending an empty file."
msgstr ""

#: flask.helpers.send_file:60 flask.helpers.send_from_directory:27 of
msgid ""
"Moved the implementation to Werkzeug. This is now a wrapper to pass some "
"Flask-specific arguments."
msgstr ""

#: flask.helpers.send_file:64 of
msgid "``filename`` may be a :class:`~os.PathLike` object."
msgstr ""

#: flask.helpers.send_file:67 of
msgid "Passing a :class:`~io.BytesIO` object supports range requests."
msgstr ""

#: flask.helpers.send_file:70 of
msgid ""
"Filenames are encoded with ASCII instead of Latin-1 for broader "
"compatibility with WSGI servers."
msgstr ""

#: flask.helpers.send_file:74 of
msgid "UTF-8 filenames as specified in :rfc:`2231` are supported."
msgstr ""

#: flask.helpers.send_file:77 of
msgid ""
"The filename is no longer automatically inferred from file objects. If "
"you want to use automatic MIME and etag support, pass a filename via "
"``filename_or_fp`` or ``attachment_filename``."
msgstr ""

#: flask.helpers.send_file:83 of
msgid "``attachment_filename`` is preferred over ``filename`` for MIME detection."
msgstr ""

#: flask.helpers.send_file:87 of
msgid "``cache_timeout`` defaults to :meth:`Flask.get_send_file_max_age`."
msgstr ""

#: flask.helpers.send_file:91 of
msgid ""
"MIME guessing and etag support for file-like objects was deprecated "
"because it was unreliable. Pass a filename if you are able to, otherwise "
"attach an etag yourself."
msgstr ""

#: flask.helpers.send_file:96 of
msgid ""
"The ``add_etags``, ``cache_timeout`` and ``conditional`` parameters were "
"added. The default behavior is to add etags."
msgstr ""

#: flask.helpers.send_from_directory:1 of
msgid "Send a file from within a directory using :func:`send_file`."
msgstr ""

#: flask.helpers.send_from_directory:11 of
msgid ""
"This is a secure way to serve files from a folder, such as static files "
"or uploads. Uses :func:`~werkzeug.security.safe_join` to ensure the path "
"coming from the client is not maliciously crafted to point outside the "
"specified directory."
msgstr ""

#: flask.helpers.send_from_directory:16 of
msgid ""
"If the final path does not point to an existing regular file, raises a "
"404 :exc:`~werkzeug.exceptions.NotFound` error."
msgstr ""

#: flask.helpers.send_from_directory:19 of
msgid "The directory that ``path`` must be located under."
msgstr ""

#: flask.helpers.send_from_directory:20 of
msgid "The path to the file to send, relative to ``directory``."
msgstr ""

#: flask.helpers.send_from_directory:22 of
msgid "Arguments to pass to :func:`send_file`."
msgstr ""

#: flask.helpers.send_from_directory:24 of
msgid "``path`` replaces the ``filename`` parameter."
msgstr ""

#: flask.helpers.safe_join:1 of
msgid ""
"Safely join zero or more untrusted path components to a base directory to"
" avoid escaping the base directory."
msgstr ""

#: flask.helpers.safe_join:4 of
msgid "The trusted base directory."
msgstr ""

#: flask.helpers.safe_join:5 of
msgid "The untrusted path components relative to the base directory."
msgstr ""

#: flask.helpers.safe_join:7 of
msgid "A safe path, otherwise ``None``."
msgstr ""

#: ../../docstring markupsafe._speedups.escape:1 of
msgid ""
"Replace the characters ``&``, ``<``, ``>``, ``'``, and ``\"`` in the "
"string with HTML-safe sequences. Use this if you need to display text "
"that might contain such characters in HTML."
msgstr ""

#: ../../docstring markupsafe._speedups.escape:3 of
msgid ""
"If the object has an ``__html__`` method, it is called and the return "
"value is assumed to already be safe for HTML."
msgstr ""

#: ../../docstring markupsafe._speedups.escape:5 of
msgid "An object to be converted to a string and escaped."
msgstr ""

#: ../../docstring markupsafe._speedups.escape:6 of
msgid "A :class:`Markup` string with the escaped text."
msgstr ""

#: markupsafe.Markup:1 of
msgid ""
"A string that is ready to be safely inserted into an HTML or XML "
"document, either because it was escaped or because it was marked safe."
msgstr ""

#: markupsafe.Markup:5 of
msgid ""
"Passing an object to the constructor converts it to text and wraps it to "
"mark it safe without escaping. To escape the text, use the :meth:`escape`"
" class method instead."
msgstr ""

#: markupsafe.Markup:16 of
msgid ""
"This implements the ``__html__()`` interface that some frameworks use. "
"Passing an object that implements ``__html__()`` will wrap the output of "
"that method, marking it safe."
msgstr ""

#: markupsafe.Markup:27 of
msgid ""
"This is a subclass of :class:`str`. It has the same methods, but escapes "
"their arguments and returns a ``Markup`` instance."
msgstr ""

#: markupsafe.Markup.escape:1 of
msgid ""
"Escape a string. Calls :func:`escape` and ensures that for subclasses the"
" correct type is returned."
msgstr ""

#: markupsafe.Markup.striptags:1 of
msgid ""
":meth:`unescape` the markup, remove tags, and normalize whitespace to "
"single spaces."
msgstr ""

#: markupsafe.Markup.unescape:1 of
msgid ""
"Convert escaped markup back into a text string. This replaces HTML "
"entities with the characters they represent."
msgstr ""

#: ../../api.rst:229
msgid "Message Flashing"
msgstr ""

#: flask.helpers.flash:1 of
msgid ""
"Flashes a message to the next request.  In order to remove the flashed "
"message from the session and to display it to the user, the template has "
"to call :func:`get_flashed_messages`."
msgstr ""

#: flask.helpers.flash:5 of
msgid "`category` parameter added."
msgstr ""

#: flask.helpers.flash:8 of
msgid "the message to be flashed."
msgstr ""

#: flask.helpers.flash:9 of
msgid ""
"the category for the message.  The following values are recommended: "
"``'message'`` for any kind of message, ``'error'`` for errors, ``'info'``"
" for information messages and ``'warning'`` for warnings.  However any "
"kind of string can be used as category."
msgstr ""

#: flask.helpers.get_flashed_messages:1 of
msgid ""
"Pulls all flashed messages from the session and returns them. Further "
"calls in the same request to the function will return the same messages."
"  By default just the messages are returned, but when `with_categories` "
"is set to ``True``, the return value will be a list of tuples in the form"
" ``(category, message)`` instead."
msgstr ""

#: flask.helpers.get_flashed_messages:7 of
msgid ""
"Filter the flashed messages to one or more categories by providing those "
"categories in `category_filter`.  This allows rendering categories in "
"separate html blocks.  The `with_categories` and `category_filter` "
"arguments are distinct:"
msgstr ""

#: flask.helpers.get_flashed_messages:12 of
msgid ""
"`with_categories` controls whether categories are returned with message "
"text (``True`` gives a tuple, where ``False`` gives just the message "
"text)."
msgstr ""

#: flask.helpers.get_flashed_messages:14 of
msgid ""
"`category_filter` filters the messages down to only those matching the "
"provided categories."
msgstr ""

#: flask.helpers.get_flashed_messages:17 of
msgid "See :doc:`/patterns/flashing` for examples."
msgstr ""

#: flask.helpers.get_flashed_messages:22 of
msgid "`category_filter` parameter added."
msgstr ""

#: flask.helpers.get_flashed_messages:19 of
msgid "`with_categories` parameter added."
msgstr ""

#: flask.helpers.get_flashed_messages:25 of
msgid "set to ``True`` to also receive categories."
msgstr ""

#: flask.helpers.get_flashed_messages:26 of
msgid ""
"filter of categories to limit return values.  Only categories in the list"
" will be returned."
msgstr ""

#: ../../api.rst:237
msgid "JSON Support"
msgstr ""

#: ../../api.rst:241
msgid ""
"Flask uses the built-in :mod:`json` module for handling JSON. It will use"
" the current blueprint's or application's JSON encoder and decoder for "
"easier customization. By default it handles some extra data types:"
msgstr ""

#: ../../api.rst:245 flask.json.JSONEncoder:4 of
msgid ""
":class:`datetime.datetime` and :class:`datetime.date` are serialized to "
":rfc:`822` strings. This is the same as the HTTP date format."
msgstr ""

#: ../../api.rst:247 flask.json.JSONEncoder:7 of
msgid ":class:`uuid.UUID` is serialized to a string."
msgstr ""

#: ../../api.rst:248 flask.json.JSONEncoder:8 of
msgid ":class:`dataclasses.dataclass` is passed to :func:`dataclasses.asdict`."
msgstr ""

#: ../../api.rst:250 flask.json.JSONEncoder:10 of
msgid ""
":class:`~markupsafe.Markup` (or any object with a ``__html__`` method) "
"will call the ``__html__`` method to get a string."
msgstr ""

#: ../../api.rst:253
msgid ""
"Jinja's ``|tojson`` filter is configured to use Flask's :func:`dumps` "
"function. The filter marks the output with ``|safe`` automatically. Use "
"the filter to render data inside ``<script>`` tags."
msgstr ""

#: flask.json.jsonify:1 of
msgid ""
"Serialize data to JSON and wrap it in a :class:`~flask.Response` with the"
" :mimetype:`application/json` mimetype."
msgstr ""

#: flask.json.jsonify:4 of
msgid ""
"Uses :func:`dumps` to serialize the data, but ``args`` and ``kwargs`` are"
" treated as data rather than arguments to :func:`json.dumps`."
msgstr ""

#: flask.json.jsonify:8 of
msgid "Single argument: Treated as a single value."
msgstr ""

#: flask.json.jsonify:9 of
msgid ""
"Multiple arguments: Treated as a list of values. ``jsonify(1, 2, 3)`` is "
"the same as ``jsonify([1, 2, 3])``."
msgstr ""

#: flask.json.jsonify:11 of
msgid ""
"Keyword arguments: Treated as a dict of values. ``jsonify(data=data, "
"errors=errors)`` is the same as ``jsonify({\"data\": data, \"errors\": "
"errors})``."
msgstr ""

#: flask.json.jsonify:14 of
msgid ""
"Passing both arguments and keyword arguments is not allowed as it's not "
"clear what should happen."
msgstr ""

#: flask.json.jsonify:29 of
msgid "Will return a JSON response like this:"
msgstr ""

#: flask.json.jsonify:39 of
msgid ""
"The default output omits indents and spaces after separators. In debug "
"mode or if :data:`JSONIFY_PRETTYPRINT_REGULAR` is ``True``, the output "
"will be formatted to be easier to read."
msgstr ""

#: flask.json.jsonify:43 of
msgid ""
"Added support for serializing top-level arrays. This introduces a "
"security risk in ancient browsers. See :ref:`security-json`."
msgstr ""

#: flask.json.dumps:1 of
msgid "Serialize an object to a string of JSON."
msgstr ""

#: flask.json.dumps:3 of
msgid ""
"Takes the same arguments as the built-in :func:`json.dumps`, with some "
"defaults from application configuration."
msgstr ""

#: flask.json.dump:6 flask.json.dumps:6 of
msgid "Object to serialize to JSON."
msgstr ""

#: flask.json.dump:8 flask.json.dumps:7 flask.json.load:7 flask.json.loads:7 of
msgid "Use this app's config instead of the active app context or defaults."
msgstr ""

#: flask.json.dumps:9 of
msgid "Extra arguments passed to :func:`json.dumps`."
msgstr ""

#: flask.json.dumps:11 of
msgid "``encoding`` is deprecated and will be removed in Flask 2.1."
msgstr ""

#: flask.json.dumps:14 flask.json.loads:15 of
msgid ""
"``app`` can be passed directly, rather than requiring an app context for "
"configuration."
msgstr ""

#: flask.json.dump:1 of
msgid "Serialize an object to JSON written to a file object."
msgstr ""

#: flask.json.dump:3 of
msgid ""
"Takes the same arguments as the built-in :func:`json.dump`, with some "
"defaults from application configuration."
msgstr ""

#: flask.json.dump:7 of
msgid "File object to write JSON to."
msgstr ""

#: flask.json.dump:10 of
msgid "Extra arguments passed to :func:`json.dump`."
msgstr ""

#: flask.json.dump:12 of
msgid ""
"Writing to a binary file, and the ``encoding`` argument, is deprecated "
"and will be removed in Flask 2.1."
msgstr ""

#: flask.json.loads:1 of
msgid "Deserialize an object from a string of JSON."
msgstr ""

#: flask.json.loads:3 of
msgid ""
"Takes the same arguments as the built-in :func:`json.loads`, with some "
"defaults from application configuration."
msgstr ""

#: flask.json.loads:6 of
msgid "JSON string to deserialize."
msgstr ""

#: flask.json.loads:9 of
msgid "Extra arguments passed to :func:`json.loads`."
msgstr ""

#: flask.json.loads:11 of
msgid ""
"``encoding`` is deprecated and will be removed in Flask 2.1. The data "
"must be a string or UTF-8 bytes."
msgstr ""

#: flask.json.load:1 of
msgid "Deserialize an object from JSON read from a file object."
msgstr ""

#: flask.json.load:3 of
msgid ""
"Takes the same arguments as the built-in :func:`json.load`, with some "
"defaults from application configuration."
msgstr ""

#: flask.json.load:6 of
msgid "File object to read JSON from."
msgstr ""

#: flask.json.load:9 of
msgid "Extra arguments passed to :func:`json.load`."
msgstr ""

#: flask.json.load:11 of
msgid ""
"``encoding`` is deprecated and will be removed in Flask 2.1. The file "
"must be text mode, or binary mode with UTF-8 bytes."
msgstr ""

#: flask.json.JSONEncoder:1 of
msgid ""
"The default JSON encoder. Handles extra types compared to the built-in "
":class:`json.JSONEncoder`."
msgstr ""

#: flask.json.JSONEncoder:13 of
msgid ""
"Assign a subclass of this to :attr:`flask.Flask.json_encoder` or "
":attr:`flask.Blueprint.json_encoder` to override the default."
msgstr ""

#: flask.json.JSONEncoder.default:1 of
msgid ""
"Convert ``o`` to a JSON serializable type. See "
":meth:`json.JSONEncoder.default`. Python does not support overriding how "
"basic types like ``str`` or ``list`` are serialized, they are handled "
"before this method."
msgstr ""

#: flask.json.JSONDecoder:1 of
msgid "The default JSON decoder."
msgstr ""

#: flask.json.JSONDecoder:3 of
msgid ""
"This does not change any behavior from the built-in "
":class:`json.JSONDecoder`."
msgstr ""

#: flask.json.JSONDecoder:6 of
msgid ""
"Assign a subclass of this to :attr:`flask.Flask.json_decoder` or "
":attr:`flask.Blueprint.json_decoder` to override the default."
msgstr ""

#: flask.json.tag:2 of
msgid "Tagged JSON"
msgstr ""

#: flask.json.tag:4 of
msgid ""
"A compact representation for lossless serialization of non-standard JSON "
"types. :class:`~flask.sessions.SecureCookieSessionInterface` uses this to"
" serialize the session data, but it may be useful in other places. It can"
" be extended to support other types."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:1 of
msgid ""
"Serializer that uses a tag system to compactly represent objects that are"
" not JSON types. Passed as the intermediate serializer to "
":class:`itsdangerous.Serializer`."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:5 of
msgid "The following extra types are supported:"
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:7 of
msgid ":class:`dict`"
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:8 of
msgid ":class:`tuple`"
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:9 of
msgid ":class:`bytes`"
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:10 of
msgid ":class:`~markupsafe.Markup`"
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:11 of
msgid ":class:`~uuid.UUID`"
msgstr ""

#: flask.json.tag.TaggedJSONSerializer:12 of
msgid ":class:`~datetime.datetime`"
msgstr ""

#: ../../docstring flask.json.tag.TaggedJSONSerializer.default_tags:1 of
msgid ""
"Tag classes to bind when creating the serializer. Other tags can be added"
" later using :meth:`~register`."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.dumps:1 of
msgid "Tag the value and dump it to a compact JSON string."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.loads:1 of
msgid "Load data from a JSON string and deserialized any tagged objects."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.register:1 of
msgid "Register a new tag with this serializer."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.register:3 of
msgid "tag class to register. Will be instantiated with this serializer instance."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.register:5 of
msgid ""
"overwrite an existing tag. If false (default), a :exc:`KeyError` is "
"raised."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.register:7 of
msgid ""
"index to insert the new tag in the tag order. Useful when the new tag is "
"a special case of an existing tag. If ``None`` (default), the tag is "
"appended to the end of the order."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.register of
msgid "引发"
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.register:11 of
msgid "if the tag key is already registered and ``force`` is not true."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.tag:1 of
msgid "Convert a value to a tagged representation if necessary."
msgstr ""

#: flask.json.tag.TaggedJSONSerializer.untag:1 of
msgid "Convert a tagged representation back to the original type."
msgstr ""

#: flask.json.tag.JSONTag:1 of
msgid "Base class for defining type tags for :class:`TaggedJSONSerializer`."
msgstr ""

#: flask.json.tag.JSONTag.check:1 of
msgid "Check if the given value should be tagged by this tag."
msgstr ""

#: ../../docstring flask.json.tag.JSONTag.key:1 of
msgid ""
"The tag to mark the serialized object with. If ``None``, this tag is only"
" used as an intermediate step during tagging."
msgstr ""

#: flask.json.tag.JSONTag.tag:1 of
msgid ""
"Convert the value to a valid JSON type and add the tag structure around "
"it."
msgstr ""

#: flask.json.tag.JSONTag.to_json:1 of
msgid ""
"Convert the Python object to an object that is a valid JSON type. The tag"
" will be added later."
msgstr ""

#: flask.json.tag.JSONTag.to_python:1 of
msgid ""
"Convert the JSON representation back to the correct type. The tag will "
"already be removed."
msgstr ""

#: flask.json.tag:15 of
msgid ""
"Let's see an example that adds support for "
":class:`~collections.OrderedDict`. Dicts don't have an order in JSON, so "
"to handle this we will dump the items as a list of ``[key, value]`` "
"pairs. Subclass :class:`JSONTag` and give it the new key ``' od'`` to "
"identify the type. The session serializer processes dicts first, so "
"insert the new tag at the front of the order since ``OrderedDict`` must "
"be processed before ``dict``."
msgstr ""

#: ../../api.rst:284
msgid "Template Rendering"
msgstr ""

#: flask.templating.render_template:1 of
msgid "Renders a template from the template folder with the given context."
msgstr ""

#: flask.templating.render_template:4 of
msgid ""
"the name of the template to be rendered, or an iterable with template "
"names the first one existing will be rendered"
msgstr ""

#: flask.templating.render_template:7 flask.templating.render_template_string:6
#: of
msgid "the variables that should be available in the context of the template."
msgstr ""

#: flask.templating.render_template_string:1 of
msgid ""
"Renders a template from the given template source string with the given "
"context. Template variables will be autoescaped."
msgstr ""

#: flask.templating.render_template_string:4 of
msgid "the source code of the template to be rendered"
msgstr ""

#: flask.helpers.get_template_attribute:1 of
msgid ""
"Loads a macro (or variable) a template exports.  This can be used to "
"invoke a macro from within Python code.  If you for example have a "
"template named :file:`_cider.html` with the following contents:"
msgstr ""

#: flask.helpers.get_template_attribute:9 of
msgid "You can access this from Python code like this::"
msgstr ""

#: flask.helpers.get_template_attribute:16 of
msgid "the name of the template"
msgstr ""

#: flask.helpers.get_template_attribute:17 of
msgid "the name of the variable of macro to access"
msgstr ""

#: ../../api.rst:295
msgid "Configuration"
msgstr ""

#: flask.config.Config:1 of
msgid ""
"Works exactly like a dict but provides ways to fill it from files or "
"special dictionaries.  There are two common patterns to populate the "
"config."
msgstr ""

#: flask.config.Config:5 of
msgid "Either you can fill the config from a config file::"
msgstr ""

#: flask.config.Config:9 of
msgid ""
"Or alternatively you can define the configuration options in the module "
"that calls :meth:`from_object` or provide an import path to a module that"
" should be loaded.  It is also possible to tell it to use the same module"
" and with that provide the configuration values just before the call::"
msgstr ""

#: flask.config.Config:19 of
msgid ""
"In both cases (loading from any Python file or loading from modules), "
"only uppercase keys are added to the config.  This makes it possible to "
"use lowercase values in the config file for temporary values that are not"
" added to the config or to define the config keys in the same file that "
"implements the application."
msgstr ""

#: flask.config.Config:25 of
msgid ""
"Probably the most interesting way to load configurations is from an "
"environment variable pointing to a file::"
msgstr ""

#: flask.config.Config:30 of
msgid ""
"In this case before launching the application you have to set this "
"environment variable to the file you want to use.  On Linux and OS X use "
"the export statement::"
msgstr ""

#: flask.config.Config:36 of
msgid "On windows use `set` instead."
msgstr ""

#: flask.config.Config:38 of
msgid ""
"path to which files are read relative from.  When the config object is "
"created by the application, this is the application's "
":attr:`~flask.Flask.root_path`."
msgstr ""

#: flask.config.Config:41 of
msgid "an optional dictionary of default values"
msgstr ""

#: flask.config.Config.from_envvar:1 of
msgid ""
"Loads a configuration from an environment variable pointing to a "
"configuration file.  This is basically just a shortcut with nicer error "
"messages for this line of code::"
msgstr ""

#: flask.config.Config.from_envvar:7 of
msgid "name of the environment variable"
msgstr ""

#: flask.config.Config.from_envvar:8 flask.config.Config.from_pyfile:8 of
msgid "set to ``True`` if you want silent failure for missing files."
msgstr ""

#: flask.config.Config.from_envvar:10 of
msgid "bool. ``True`` if able to load config, ``False`` otherwise."
msgstr ""

#: flask.config.Config.from_file:1 of
msgid ""
"Update the values in the config from a file that is loaded using the "
"``load`` parameter. The loaded data is passed to the :meth:`from_mapping`"
" method."
msgstr ""

#: flask.config.Config.from_file:10 of
msgid ""
"The path to the data file. This can be an absolute path or relative to "
"the config root path."
msgstr ""

#: flask.config.Config.from_file:12 of
msgid ""
"A callable that takes a file handle and returns a mapping of loaded data "
"from the file."
msgstr ""

#: flask.config.Config.from_file:16 flask.config.Config.from_json:6 of
msgid "Ignore the file if it doesn't exist."
msgstr ""

#: flask.config.Config.from_json:1 of
msgid ""
"Update the values in the config from a JSON file. The loaded data is "
"passed to the :meth:`from_mapping` method."
msgstr ""

#: flask.config.Config.from_json:4 of
msgid ""
"The path to the JSON file. This can be an absolute path or relative to "
"the config root path."
msgstr ""

#: flask.config.Config.from_json:8 of
msgid ""
"Will be removed in Flask 2.1. Use :meth:`from_file` instead. This was "
"removed early in 2.0.0, was added back in 2.0.1."
msgstr ""

#: flask.config.Config.from_mapping:1 of
msgid "Updates the config like :meth:`update` ignoring items with non-upper keys."
msgstr ""

#: flask.config.Config.from_object:1 of
msgid ""
"Updates the values from the given object.  An object can be of one of the"
" following two types:"
msgstr ""

#: flask.config.Config.from_object:4 of
msgid "a string: in this case the object with that name will be imported"
msgstr ""

#: flask.config.Config.from_object:5 of
msgid "an actual object reference: that object is used directly"
msgstr ""

#: flask.config.Config.from_object:7 of
msgid ""
"Objects are usually either modules or classes. :meth:`from_object` loads "
"only the uppercase attributes of the module/class. A ``dict`` object will"
" not work with :meth:`from_object` because the keys of a ``dict`` are not"
" attributes of the ``dict`` class."
msgstr ""

#: flask.config.Config.from_object:12 of
msgid "Example of module-based configuration::"
msgstr ""

#: flask.config.Config.from_object:18 of
msgid ""
"Nothing is done to the object before loading. If the object is a class "
"and has ``@property`` attributes, it needs to be instantiated before "
"being passed to this method."
msgstr ""

#: flask.config.Config.from_object:22 of
msgid ""
"You should not use this function to load the actual configuration but "
"rather configuration defaults.  The actual config should be loaded with "
":meth:`from_pyfile` and ideally from a location not within the package "
"because the package might be installed system wide."
msgstr ""

#: flask.config.Config.from_object:27 of
msgid ""
"See :ref:`config-dev-prod` for an example of class-based configuration "
"using :meth:`from_object`."
msgstr ""

#: flask.config.Config.from_object:30 of
msgid "an import name or object"
msgstr ""

#: flask.config.Config.from_pyfile:1 of
msgid ""
"Updates the values in the config from a Python file.  This function "
"behaves as if the file was imported as module with the "
":meth:`from_object` function."
msgstr ""

#: flask.config.Config.from_pyfile:5 of
msgid ""
"the filename of the config.  This can either be an absolute filename or a"
" filename relative to the root path."
msgstr ""

#: flask.config.Config.from_pyfile:11 of
msgid "`silent` parameter."
msgstr ""

#: flask.config.Config.get_namespace:1 of
msgid ""
"Returns a dictionary containing a subset of configuration options that "
"match the specified namespace/prefix. Example usage::"
msgstr ""

#: flask.config.Config.get_namespace:9 of
msgid "The resulting dictionary `image_store_config` would look like::"
msgstr ""

#: flask.config.Config.get_namespace:17 of
msgid ""
"This is often useful when configuration options map directly to keyword "
"arguments in functions or class constructors."
msgstr ""

#: flask.config.Config.get_namespace:20 of
msgid "a configuration namespace"
msgstr ""

#: flask.config.Config.get_namespace:21 of
msgid ""
"a flag indicating if the keys of the resulting dictionary should be "
"lowercase"
msgstr ""

#: flask.config.Config.get_namespace:23 of
msgid ""
"a flag indicating if the keys of the resulting dictionary should not "
"include the namespace"
msgstr ""

#: ../../api.rst:302
msgid "Stream Helpers"
msgstr ""

#: flask.helpers.stream_with_context:1 of
msgid ""
"Request contexts disappear when the response is started on the server. "
"This is done for efficiency reasons and to make it less likely to "
"encounter memory leaks with badly written WSGI middlewares.  The downside"
" is that if you are using streamed responses, the generator cannot access"
" request bound information any more."
msgstr ""

#: flask.helpers.stream_with_context:7 of
msgid "This function however can help you keep the context around for longer::"
msgstr ""

#: flask.helpers.stream_with_context:20 of
msgid "Alternatively it can also be used around a specific generator::"
msgstr ""

#: ../../api.rst:307
msgid "Useful Internals"
msgstr ""

#: flask.ctx.RequestContext:1 of
msgid ""
"The request context contains all request relevant information.  It is "
"created at the beginning of the request and pushed to the "
"`_request_ctx_stack` and removed at the end of it.  It will create the "
"URL adapter and request object for the WSGI environment provided."
msgstr ""

#: flask.ctx.RequestContext:6 of
msgid ""
"Do not attempt to use this class directly, instead use "
":meth:`~flask.Flask.test_request_context` and "
":meth:`~flask.Flask.request_context` to create this object."
msgstr ""

#: flask.ctx.RequestContext:10 of
msgid ""
"When the request context is popped, it will evaluate all the functions "
"registered on the application for teardown execution "
"(:meth:`~flask.Flask.teardown_request`)."
msgstr ""

#: flask.ctx.RequestContext:14 of
msgid ""
"The request context is automatically popped at the end of the request for"
" you.  In debug mode the request context is kept around if exceptions "
"happen so that interactive debuggers have a chance to introspect the "
"data.  With 0.4 this can also be forced for requests that did not fail "
"and outside of ``DEBUG`` mode.  By setting ``'flask._preserve_context'`` "
"to ``True`` on the WSGI environment the context will not pop itself at "
"the end of the request.  This is used by the "
":meth:`~flask.Flask.test_client` for example to implement the deferred "
"cleanup functionality."
msgstr ""

#: flask.ctx.RequestContext:24 of
msgid ""
"You might find this helpful for unittests where you need the information "
"from the context local around for a little longer.  Make sure to properly"
" :meth:`~werkzeug.LocalStack.pop` the stack yourself in that situation, "
"otherwise your unittests will leak memory."
msgstr ""

#: flask.ctx.RequestContext.copy:1 of
msgid ""
"Creates a copy of this request context with the same request object. This"
" can be used to move a request context to a different greenlet. Because "
"the actual request object is the same this cannot be used to move a "
"request context to a different thread unless access to the request object"
" is locked."
msgstr ""

#: flask.ctx.RequestContext.copy:9 of
msgid ""
"The current session object is used instead of reloading the original "
"data. This prevents `flask.session` pointing to an out-of-date object."
msgstr ""

#: flask.ctx.RequestContext.match_request:1 of
msgid "Can be overridden by a subclass to hook into the matching of the request."
msgstr ""

#: flask.ctx.RequestContext.pop:1 of
msgid ""
"Pops the request context and unbinds it by doing that.  This will also "
"trigger the execution of functions registered by the "
":meth:`~flask.Flask.teardown_request` decorator."
msgstr ""

#: flask.ctx.RequestContext.pop:5 of
msgid "Added the `exc` argument."
msgstr ""

#: flask.ctx.RequestContext.push:1 of
msgid "Binds the request context to the current context."
msgstr ""

#: ../../api.rst:314
msgid ""
"The internal :class:`~werkzeug.local.LocalStack` that holds "
":class:`~flask.ctx.RequestContext` instances. Typically, the "
":data:`request` and :data:`session` proxies should be accessed instead of"
" the stack. It may be useful to access the stack in extension code."
msgstr ""

#: ../../api.rst:320
msgid "The following attributes are always present on each layer of the stack:"
msgstr ""

#: ../../api.rst:324
msgid "`app`"
msgstr ""

#: ../../api.rst:324
msgid "the active Flask application."
msgstr ""

#: ../../api.rst:327
msgid "`url_adapter`"
msgstr ""

#: ../../api.rst:327
msgid "the URL adapter that was used to match the request."
msgstr ""

#: ../../api.rst:330
msgid "`request`"
msgstr ""

#: ../../api.rst:330
msgid "the current request object."
msgstr ""

#: ../../api.rst:333
msgid "`session`"
msgstr ""

#: ../../api.rst:333
msgid "the active session object."
msgstr ""

#: ../../api.rst:336
msgid "`g`"
msgstr ""

#: ../../api.rst:336
msgid "an object with all the attributes of the :data:`flask.g` object."
msgstr ""

#: ../../api.rst:339
msgid "`flashes`"
msgstr ""

#: ../../api.rst:339
msgid "an internal cache for the flashed messages."
msgstr ""

#: ../../api.rst:341 ../../api.rst:515
msgid "Example usage::"
msgstr ""

#: flask.ctx.AppContext:1 of
msgid ""
"The application context binds an application object implicitly to the "
"current thread or greenlet, similar to how the :class:`RequestContext` "
"binds request information.  The application context is also implicitly "
"created if a request context is created but the application is not on top"
" of the individual application context."
msgstr ""

#: flask.ctx.AppContext.pop:1 of
msgid "Pops the app context."
msgstr ""

#: flask.ctx.AppContext.push:1 of
msgid "Binds the app context to the current context."
msgstr ""

#: ../../api.rst:355
msgid ""
"The internal :class:`~werkzeug.local.LocalStack` that holds "
":class:`~flask.ctx.AppContext` instances. Typically, the "
":data:`current_app` and :data:`g` proxies should be accessed instead of "
"the stack. Extensions can access the contexts on the stack as a namespace"
" to store data."
msgstr ""

#: flask.blueprints.BlueprintSetupState:1 of
msgid ""
"Temporary holder object for registering a blueprint with the application."
"  An instance of this class is created by the "
":meth:`~flask.Blueprint.make_setup_state` method and later passed to all "
"register callback functions."
msgstr ""

#: flask.blueprints.BlueprintSetupState.add_url_rule:1 of
msgid ""
"A helper method to register a rule (and optionally a view function) to "
"the application.  The endpoint is automatically prefixed with the "
"blueprint's name."
msgstr ""

#: ../../docstring flask.blueprints.BlueprintSetupState.app:1 of
msgid "a reference to the current application"
msgstr ""

#: ../../docstring flask.blueprints.BlueprintSetupState.blueprint:1 of
msgid "a reference to the blueprint that created this setup state."
msgstr ""

#: ../../docstring flask.blueprints.BlueprintSetupState.first_registration:1 of
msgid ""
"as blueprints can be registered multiple times with the application and "
"not everything wants to be registered multiple times on it, this "
"attribute can be used to figure out if the blueprint was registered in "
"the past already."
msgstr ""

#: ../../docstring flask.blueprints.BlueprintSetupState.options:1 of
msgid ""
"a dictionary with all options that were passed to the "
":meth:`~flask.Flask.register_blueprint` method."
msgstr ""

#: ../../docstring flask.blueprints.BlueprintSetupState.subdomain:1 of
msgid "The subdomain that the blueprint should be active for, ``None`` otherwise."
msgstr ""

#: ../../docstring flask.blueprints.BlueprintSetupState.url_defaults:1 of
msgid ""
"A dictionary with URL defaults that is added to each and every URL that "
"was defined with the blueprint."
msgstr ""

#: ../../docstring flask.blueprints.BlueprintSetupState.url_prefix:1 of
msgid "The prefix that should be used for all URLs defined on the blueprint."
msgstr ""

#: ../../api.rst:369
msgid "Signals"
msgstr ""

#: ../../api.rst:375
msgid ""
"``True`` if the signaling system is available.  This is the case when "
"`blinker`_ is installed."
msgstr ""

#: ../../api.rst:378
msgid "The following signals exist in Flask:"
msgstr ""

#: ../../api.rst:382
msgid ""
"This signal is sent when a template was successfully rendered.  The "
"signal is invoked with the instance of the template as `template` and the"
" context as dictionary (named `context`)."
msgstr ""

#: ../../api.rst:386 ../../api.rst:403 ../../api.rst:420 ../../api.rst:433
#: ../../api.rst:478 ../../api.rst:497 ../../api.rst:552
msgid "Example subscriber::"
msgstr ""

#: ../../api.rst:399
msgid ""
"This signal is sent before template rendering process. The signal is "
"invoked with the instance of the template as `template` and the context "
"as dictionary (named `context`)."
msgstr ""

#: ../../api.rst:415
msgid ""
"This signal is sent when the request context is set up, before any "
"request processing happens.  Because the request context is already "
"bound, the subscriber can access the request with the standard global "
"proxies such as :class:`~flask.request`."
msgstr ""

#: ../../api.rst:430
msgid ""
"This signal is sent right before the response is sent to the client. It "
"is passed the response to be sent named `response`."
msgstr ""

#: ../../api.rst:444
msgid ""
"This signal is sent when an unhandled exception happens during request "
"processing, including when debugging. The exception is passed to the "
"subscriber as ``exception``."
msgstr ""

#: ../../api.rst:448
msgid ""
"This signal is not sent for :exc:`~werkzeug.exceptions.HTTPException`, or"
" other exceptions that have error handlers registered, unless the "
"exception was raised from an error handler."
msgstr ""

#: ../../api.rst:453
msgid ""
"This example shows how to do some extra logging if a theoretical "
"``SecurityException`` was raised:"
msgstr ""

#: ../../api.rst:473
msgid ""
"This signal is sent when the request is tearing down.  This is always "
"called, even if an exception is caused.  Currently functions listening to"
" this signal are called after the regular teardown handlers, but this is "
"not something you can rely on."
msgstr ""

#: ../../api.rst:486
msgid ""
"As of Flask 0.9, this will also be passed an `exc` keyword argument that "
"has a reference to the exception that caused the teardown if there was "
"one."
msgstr ""

#: ../../api.rst:492
msgid ""
"This signal is sent when the app context is tearing down.  This is always"
" called, even if an exception is caused.  Currently functions listening "
"to this signal are called after the regular teardown handlers, but this "
"is not something you can rely on."
msgstr ""

#: ../../api.rst:505
msgid ""
"This will also be passed an `exc` keyword argument that has a reference "
"to the exception that caused the teardown if there was one."
msgstr ""

#: ../../api.rst:510
msgid ""
"This signal is sent when an application context is pushed.  The sender is"
" the application.  This is usually useful for unittests in order to "
"temporarily hook in information.  For instance it can be used to set a "
"resource early onto the `g` object."
msgstr ""

#: ../../api.rst:527
msgid "And in the testcode::"
msgstr ""

#: ../../api.rst:539
msgid ""
"This signal is sent when an application context is popped.  The sender is"
" the application.  This usually falls in line with the "
":data:`appcontext_tearing_down` signal."
msgstr ""

#: ../../api.rst:548
msgid ""
"This signal is sent when the application is flashing a message.  The "
"messages is sent as `message` keyword argument and the category as "
"`category`."
msgstr ""

#: ../../api.rst:565
msgid ""
"An alias for :class:`blinker.base.Namespace` if blinker is available, "
"otherwise a dummy class that creates fake signals.  This class is "
"available for Flask extensions that want to provide the same fallback "
"system as Flask itself."
msgstr ""

#: ../../api.rst:572
msgid ""
"Creates a new signal for this namespace if blinker is available, "
"otherwise returns a fake signal that has a send method that will do "
"nothing but will fail with a :exc:`RuntimeError` for all other "
"operations, including connecting."
msgstr ""

#: ../../api.rst:582
msgid "Class-Based Views"
msgstr ""

#: flask.views.View:1 of
msgid ""
"Alternative way to use view functions.  A subclass has to implement "
":meth:`dispatch_request` which is called with the view arguments from the"
" URL routing system.  If :attr:`methods` is provided the methods do not "
"have to be passed to the :meth:`~flask.Flask.add_url_rule` method "
"explicitly::"
msgstr ""

#: flask.views.View:15 of
msgid ""
"When you want to decorate a pluggable view you will have to either do "
"that when the view function is created (by wrapping the return value of "
":meth:`as_view`) or you can use the :attr:`decorators` attribute::"
msgstr ""

#: flask.views.View:26 of
msgid ""
"The decorators stored in the decorators list are applied one after "
"another when the view function is created.  Note that you can *not* use "
"the class based decorators since those would decorate the view class and "
"not the generated view function!"
msgstr ""

#: flask.views.View.as_view:1 of
msgid ""
"Converts the class into an actual view function that can be used with the"
" routing system.  Internally this generates a function on the fly which "
"will instantiate the :class:`View` on each request and call the "
":meth:`dispatch_request` method on it."
msgstr ""

#: flask.views.View.as_view:6 of
msgid ""
"The arguments passed to :meth:`as_view` are forwarded to the constructor "
"of the class."
msgstr ""

#: ../../docstring flask.views.View.decorators:1 of
msgid ""
"The canonical way to decorate class-based views is to decorate the return"
" value of as_view().  However since this moves parts of the logic from "
"the class declaration to the place where it's hooked into the routing "
"system."
msgstr ""

#: ../../docstring flask.views.View.decorators:6 of
msgid ""
"You can place one or more decorators in this list and whenever the view "
"function is created the result is automatically decorated."
msgstr ""

#: flask.views.MethodView.dispatch_request:1
#: flask.views.View.dispatch_request:1 of
msgid ""
"Subclasses have to override this method to implement the actual view "
"function code.  This method is called with all the arguments from the URL"
" rule."
msgstr ""

#: ../../docstring flask.views.View.methods:1 of
msgid "A list of methods this view can handle."
msgstr ""

#: ../../docstring flask.views.View.provide_automatic_options:1 of
msgid "Setting this disables or force-enables the automatic options handling."
msgstr ""

#: flask.views.MethodView:1 of
msgid ""
"A class-based view that dispatches request methods to the corresponding "
"class methods. For example, if you implement a ``get`` method, it will be"
" used to handle ``GET`` requests. ::"
msgstr ""

#: ../../api.rst:597
msgid "URL Route Registrations"
msgstr ""

#: ../../api.rst:599
msgid "Generally there are three ways to define rules for the routing system:"
msgstr ""

#: ../../api.rst:601
msgid "You can use the :meth:`flask.Flask.route` decorator."
msgstr ""

#: ../../api.rst:602
msgid "You can use the :meth:`flask.Flask.add_url_rule` function."
msgstr ""

#: ../../api.rst:603
msgid ""
"You can directly access the underlying Werkzeug routing system which is "
"exposed as :attr:`flask.Flask.url_map`."
msgstr ""

#: ../../api.rst:606
msgid ""
"Variable parts in the route can be specified with angular brackets "
"(``/user/<username>``).  By default a variable part in the URL accepts "
"any string without a slash however a different converter can be specified"
" as well by using ``<converter:name>``."
msgstr ""

#: ../../api.rst:611
msgid "Variable parts are passed to the view function as keyword arguments."
msgstr ""

#: ../../api.rst:613
msgid "The following converters are available:"
msgstr ""

#: ../../api.rst:616
msgid "`string`"
msgstr ""

#: ../../api.rst:616
msgid "accepts any text without a slash (the default)"
msgstr ""

#: ../../api.rst:617
msgid "`int`"
msgstr ""

#: ../../api.rst:617
msgid "accepts integers"
msgstr ""

#: ../../api.rst:618
msgid "`float`"
msgstr ""

#: ../../api.rst:618
msgid "like `int` but for floating point values"
msgstr ""

#: ../../api.rst:619
msgid "`path`"
msgstr ""

#: ../../api.rst:619
msgid "like the default but also accepts slashes"
msgstr ""

#: ../../api.rst:620
msgid "`any`"
msgstr ""

#: ../../api.rst:620
msgid "matches one of the items provided"
msgstr ""

#: ../../api.rst:621
msgid "`uuid`"
msgstr ""

#: ../../api.rst:621
msgid "accepts UUID strings"
msgstr ""

#: ../../api.rst:624
msgid "Custom converters can be defined using :attr:`flask.Flask.url_map`."
msgstr ""

#: ../../api.rst:626
msgid "Here are some examples::"
msgstr ""

#: ../../api.rst:640
msgid ""
"An important detail to keep in mind is how Flask deals with trailing "
"slashes.  The idea is to keep each URL unique so the following rules "
"apply:"
msgstr ""

#: ../../api.rst:644
msgid ""
"If a rule ends with a slash and is requested without a slash by the user,"
" the user is automatically redirected to the same page with a trailing "
"slash attached."
msgstr ""

#: ../../api.rst:647
msgid ""
"If a rule does not end with a trailing slash and the user requests the "
"page with a trailing slash, a 404 not found is raised."
msgstr ""

#: ../../api.rst:650
msgid ""
"This is consistent with how web servers deal with static files.  This "
"also makes it possible to use relative link targets safely."
msgstr ""

#: ../../api.rst:653
msgid ""
"You can also define multiple rules for the same function.  They have to "
"be unique however.  Defaults can also be specified.  Here for example is "
"a definition for a URL that accepts an optional page::"
msgstr ""

#: ../../api.rst:662
msgid ""
"This specifies that ``/users/`` will be the URL for page one and "
"``/users/page/N`` will be the URL for page ``N``."
msgstr ""

#: ../../api.rst:665
msgid ""
"If a URL contains a default value, it will be redirected to its simpler "
"form with a 301 redirect. In the above example, ``/users/page/1`` will be"
" redirected to ``/users/``. If your route handles ``GET`` and ``POST`` "
"requests, make sure the default route only handles ``GET``, as redirects "
"can't preserve form data. ::"
msgstr ""

#: ../../api.rst:676
msgid ""
"Here are the parameters that :meth:`~flask.Flask.route` and "
":meth:`~flask.Flask.add_url_rule` accept.  The only difference is that "
"with the route parameter the view function is defined with the decorator "
"instead of the `view_func` parameter."
msgstr ""

#: ../../api.rst:682
msgid "`rule`"
msgstr ""

#: ../../api.rst:682
msgid "the URL rule as string"
msgstr ""

#: ../../api.rst:683
msgid "`endpoint`"
msgstr ""

#: ../../api.rst:683
msgid ""
"the endpoint for the registered URL rule.  Flask itself assumes that the "
"name of the view function is the name of the endpoint if not explicitly "
"stated."
msgstr ""

#: ../../api.rst:686
msgid "`view_func`"
msgstr ""

#: ../../api.rst:686
msgid ""
"the function to call when serving a request to the provided endpoint.  If"
" this is not provided one can specify the function later by storing it in"
" the :attr:`~flask.Flask.view_functions` dictionary with the endpoint as "
"key."
msgstr ""

#: ../../api.rst:691
msgid "`defaults`"
msgstr ""

#: ../../api.rst:691
msgid ""
"A dictionary with defaults for this rule.  See the example above for how "
"defaults work."
msgstr ""

#: ../../api.rst:693
msgid "`subdomain`"
msgstr ""

#: ../../api.rst:693
msgid ""
"specifies the rule for the subdomain in case subdomain matching is in "
"use.  If not specified the default subdomain is assumed."
msgstr ""

#: ../../api.rst:696
msgid "`**options`"
msgstr ""

#: ../../api.rst:696
msgid ""
"the options to be forwarded to the underlying "
":class:`~werkzeug.routing.Rule` object.  A change to Werkzeug is handling"
" of method options.  methods is a list of methods this rule should be "
"limited to (``GET``, ``POST`` etc.).  By default a rule just listens for "
"``GET`` (and implicitly ``HEAD``).  Starting with Flask 0.6, ``OPTIONS`` "
"is implicitly added and handled by the standard request handling.  They "
"have to be specified as keyword arguments."
msgstr ""

#: ../../api.rst:708
msgid "View Function Options"
msgstr ""

#: ../../api.rst:710
msgid ""
"For internal usage the view functions can have some attributes attached "
"to customize behavior the view function would normally not have control "
"over. The following attributes can be provided optionally to either "
"override some defaults to :meth:`~flask.Flask.add_url_rule` or general "
"behavior:"
msgstr ""

#: ../../api.rst:715
msgid ""
"`__name__`: The name of a function is by default used as endpoint.  If "
"endpoint is provided explicitly this value is used.  Additionally this "
"will be prefixed with the name of the blueprint by default which cannot "
"be customized from the function itself."
msgstr ""

#: ../../api.rst:720
msgid ""
"`methods`: If methods are not provided when the URL rule is added, Flask "
"will look on the view function object itself if a `methods` attribute "
"exists.  If it does, it will pull the information for the methods from "
"there."
msgstr ""

#: ../../api.rst:725
msgid ""
"`provide_automatic_options`: if this attribute is set Flask will either "
"force enable or disable the automatic implementation of the HTTP "
"``OPTIONS`` response.  This can be useful when working with decorators "
"that want to customize the ``OPTIONS`` response on a per-view basis."
msgstr ""

#: ../../api.rst:731
msgid ""
"`required_methods`: if this attribute is set, Flask will always add these"
" methods when registering a URL rule even if the methods were explicitly "
"overridden in the ``route()`` call."
msgstr ""

#: ../../api.rst:735
msgid "Full example::"
msgstr ""

#: ../../api.rst:747
msgid "The `provide_automatic_options` functionality was added."
msgstr ""

#: ../../api.rst:751
msgid "Command Line Interface"
msgstr ""

#: flask.cli.FlaskGroup:1 of
msgid ""
"Special subclass of the :class:`AppGroup` group that supports loading "
"more commands from the configured Flask app.  Normally a developer does "
"not have to interface with this class but there are some very advanced "
"use cases for which it makes sense to create an instance of this. see "
":ref:`custom-scripts`."
msgstr ""

#: flask.cli.FlaskGroup:7 of
msgid "if this is True then the default run and shell commands will be added."
msgstr ""

#: flask.cli.FlaskGroup:9 of
msgid "adds the ``--version`` option."
msgstr ""

#: flask.cli.FlaskGroup:10 of
msgid ""
"an optional callback that is passed the script info and returns the "
"loaded app."
msgstr ""

#: flask.cli.FlaskGroup:15 of
msgid "Set the app's debug flag based on the active environment"
msgstr ""

#: flask.cli.FlaskGroup.get_command:1 of
msgid ""
"Given a context and a command name, this returns a :class:`Command` "
"object if it exists or returns `None`."
msgstr ""

#: flask.cli.FlaskGroup.list_commands:1 of
msgid "Returns a list of subcommand names in the order they should appear."
msgstr ""

#: flask.cli.FlaskGroup.main:1 of
msgid ""
"This is the way to invoke a script with all the bells and whistles as a "
"command line application.  This will always terminate the application "
"after a call.  If this is not wanted, ``SystemExit`` needs to be caught."
msgstr ""

#: flask.cli.FlaskGroup.main:6 of
msgid ""
"This method is also available by directly calling the instance of a "
":class:`Command`."
msgstr ""

#: flask.cli.FlaskGroup.main:9 of
msgid ""
"the arguments that should be used for parsing.  If not provided, "
"``sys.argv[1:]`` is used."
msgstr ""

#: flask.cli.FlaskGroup.main:11 of
msgid ""
"the program name that should be used.  By default the program name is "
"constructed by taking the file name from ``sys.argv[0]``."
msgstr ""

#: flask.cli.FlaskGroup.main:14 of
msgid ""
"the environment variable that controls the bash completion support.  The "
"default is ``\"_<prog_name>_COMPLETE\"`` with prog_name in uppercase."
msgstr ""

#: flask.cli.FlaskGroup.main:18 of
msgid ""
"the default behavior is to invoke the script in standalone mode.  Click "
"will then handle exceptions and convert them into error messages and the "
"function will never return but shut down the interpreter.  If this is set"
" to `False` they will be propagated to the caller and the return value of"
" this function is the return value of :meth:`invoke`."
msgstr ""

#: flask.cli.FlaskGroup.main:27 of
msgid ""
"Expand glob patterns, user dir, and env vars in command line args on "
"Windows."
msgstr ""

#: flask.cli.FlaskGroup.main:29 of
msgid ""
"extra keyword arguments are forwarded to the context constructor.  See "
":class:`Context` for more information."
msgstr ""

#: flask.cli.FlaskGroup.main:32 of
msgid ""
"Added the ``windows_expand_args`` parameter to allow disabling command "
"line arg expansion on Windows."
msgstr ""

#: flask.cli.FlaskGroup.main:36 of
msgid ""
"When taking arguments from ``sys.argv`` on Windows, glob patterns, user "
"dir, and env vars are expanded."
msgstr ""

#: flask.cli.FlaskGroup.main:40 of
msgid "Added the ``standalone_mode`` parameter."
msgstr ""

#: flask.cli.AppGroup:1 of
msgid ""
"This works similar to a regular click :class:`~click.Group` but it "
"changes the behavior of the :meth:`command` decorator so that it "
"automatically wraps the functions in :func:`with_appcontext`."
msgstr ""

#: flask.cli.AppGroup:5 of
msgid "Not to be confused with :class:`FlaskGroup`."
msgstr ""

#: flask.cli.AppGroup.command:1 of
msgid ""
"This works exactly like the method of the same name on a regular "
":class:`click.Group` but it wraps callbacks in :func:`with_appcontext` "
"unless it's disabled by passing ``with_appcontext=False``."
msgstr ""

#: flask.cli.AppGroup.group:1 of
msgid ""
"This works exactly like the method of the same name on a regular "
":class:`click.Group` but it defaults the group class to "
":class:`AppGroup`."
msgstr ""

#: flask.cli.ScriptInfo:1 of
msgid ""
"Helper object to deal with Flask applications.  This is usually not "
"necessary to interface with as it's used internally in the dispatching to"
" click.  In future versions of Flask this object will most likely play a "
"bigger role.  Typically it's created automatically by the "
":class:`FlaskGroup` but you can also manually create it and pass it "
"onwards as click object."
msgstr ""

#: ../../docstring flask.cli.ScriptInfo.app_import_path:1 of
msgid "Optionally the import path for the Flask application."
msgstr ""

#: ../../docstring flask.cli.ScriptInfo.create_app:1 of
msgid ""
"Optionally a function that is passed the script info to create the "
"instance of the application."
msgstr ""

#: ../../docstring flask.cli.ScriptInfo.data:1 of
msgid ""
"A dictionary with arbitrary data that can be associated with this script "
"info."
msgstr ""

#: flask.cli.ScriptInfo.load_app:1 of
msgid ""
"Loads the Flask app (if not yet loaded) and returns it.  Calling this "
"multiple times will just result in the already loaded app to be returned."
msgstr ""

#: flask.cli.load_dotenv:1 of
msgid "Load \"dotenv\" files in order of precedence to set environment variables."
msgstr ""

#: flask.cli.load_dotenv:3 of
msgid ""
"If an env var is already set it is not overwritten, so earlier files in "
"the list are preferred over later files."
msgstr ""

#: flask.cli.load_dotenv:6 of
msgid "This is a no-op if `python-dotenv`_ is not installed."
msgstr ""

#: flask.cli.load_dotenv:10 of
msgid "Load the file at this location instead of searching."
msgstr ""

#: flask.cli.load_dotenv:11 of
msgid "``True`` if a file was loaded."
msgstr ""

#: flask.cli.load_dotenv:17 of
msgid "When loading the env files, set the default encoding to UTF-8."
msgstr ""

#: flask.cli.load_dotenv:13 of
msgid ""
"Returns ``False`` when python-dotenv is not installed, or when the given "
"path isn't a file."
msgstr ""

#: flask.cli.with_appcontext:1 of
msgid ""
"Wraps a callback so that it's guaranteed to be executed with the script's"
" application context.  If callbacks are registered directly to the "
"``app.cli`` object then they are wrapped with this function by default "
"unless it's disabled."
msgstr ""

#: ../../api.rst:770
msgid ""
"Marks a function so that an instance of :class:`ScriptInfo` is passed as "
"first argument to the click callback."
msgstr ""

#: ../../docstring flask.cli.run_command:1 of
msgid "Run a local development server."
msgstr ""

#: ../../docstring flask.cli.run_command:3 of
msgid ""
"This server is for development purposes only. It does not provide the "
"stability, security, or performance of production WSGI servers."
msgstr ""

#: ../../docstring flask.cli.run_command:6 of
msgid ""
"The reloader and debugger are enabled by default if FLASK_ENV=development"
" or FLASK_DEBUG=1."
msgstr ""

#: ../../docstring flask.cli.shell_command:1 of
msgid ""
"Run an interactive Python shell in the context of a given Flask "
"application.  The application will populate the default namespace of this"
" shell according to its configuration."
msgstr ""

#: ../../docstring flask.cli.shell_command:5 of
msgid ""
"This is useful for executing small snippets of management code without "
"having to manually configure the application."
msgstr ""

#~ msgid "Parameters"
#~ msgstr ""

#~ msgid "Return type"
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "Raises"
#~ msgstr ""

