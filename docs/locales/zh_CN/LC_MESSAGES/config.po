# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# Doge Gui <guiqiqi187@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-25 19:31+0800\n"
"PO-Revision-Date: 2021-07-05 16:55+0800\n"
"Language-Team: zh_CN <withlihui@gmail.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Last-Translator: Doge Gui <guiqiqi187@gmail.com>\n"
"Language: zh_CN\n"
"X-Generator: Poedit 2.4.3\n"

#: ../../config.rst:2
msgid "Configuration Handling"
msgstr "配置处理"

#: ../../config.rst:4
msgid ""
"Applications need some kind of configuration.  There are different settings you "
"might want to change depending on the application environment like toggling the "
"debug mode, setting the secret key, and other such environment-specific things."
msgstr ""
"程序在运行之前需要一些配置。根据不同的运行环境，你可能想要调整 Debug 开关、设置"
"密钥、或者根据环境更改其他类型的设置。"

#: ../../config.rst:9
msgid ""
"The way Flask is designed usually requires the configuration to be available "
"when the application starts up.  You can hard code the configuration in the "
"code, which for many small applications is not actually that bad, but there are "
"better ways."
msgstr ""
"通常在 Flask 应用启动的时候就要求配置已经可用。你可以使用硬编码将配置写入代码，"
"事实上这对于很多的小型应用来说并没有那么糟糕，但仍然有很多更好的方法来解决这个问"
"题。"

#: ../../config.rst:14
msgid ""
"Independent of how you load your config, there is a config object available "
"which holds the loaded configuration values: The :attr:`~flask.Flask.config` "
"attribute of the :class:`~flask.Flask` object.  This is the place where Flask "
"itself puts certain configuration values and also where extensions can put "
"their configuration values.  But this is also where you can have your own "
"configuration."
msgstr ""
"无论你如何加载配置，有一个对象可以用来保存已经加载了的配置值：:class:`~flask."
"Flask` 对象的 :attr:`~flask.Flask.config` 属性。这是 Flask 自身放置某些配置值的"
"地方，扩展也可以在这里保存他们的配置。同时，你也可以在这里存储你自己的配置。"

#: ../../config.rst:23
msgid "Configuration Basics"
msgstr "基础配置"

#: ../../config.rst:25
msgid ""
"The :attr:`~flask.Flask.config` is actually a subclass of a dictionary and can "
"be modified just like any dictionary::"
msgstr ""
":attr:`~flask.Flask.config` 实际上是字典类的一个子类，它可以像任何字典一样被编"
"辑："

#: ../../config.rst:31
msgid ""
"Certain configuration values are also forwarded to the :attr:`~flask.Flask` "
"object so you can read and write them from there::"
msgstr ""
"某些配置同时也会被转发到 :attr:`~flask.Flask` 对象，所以你可以在那里读写它们："

#: ../../config.rst:36
msgid ""
"To update multiple keys at once you can use the :meth:`dict.update` method::"
msgstr "如果你想要一次更新多个设置，可以使用 :meth:`dict.update` 方法："

#: ../../config.rst:46
msgid "Environment and Debug Features"
msgstr "环境变量与 Debug 功能"

#: ../../config.rst:48
msgid ""
"The :data:`ENV` and :data:`DEBUG` config values are special because they may "
"behave inconsistently if changed after the app has begun setting up. In order "
"to set the environment and debug mode reliably, Flask uses environment "
"variables."
msgstr ""
":data:`ENV` 和 :data:`DEBUG` 配置很特殊，因为如果在应用开始设置之后对它们进行更"
"改，可能会出现不一致的行为。为了保证环境和测试模式的可靠性，Flask 使用了环境变"
"量。"

#: ../../config.rst:53
msgid ""
"The environment is used to indicate to Flask, extensions, and other programs, "
"like Sentry, what context Flask is running in. It is controlled with the :"
"envvar:`FLASK_ENV` environment variable and defaults to ``production``."
msgstr ""
"环境变量用于向 Flask、扩展以及其他程序（像是Sentry）指示 Flask 正在运行的上下"
"文。它通过环境变量 :envvar:`FLASK_ENV` 控制，默认为 ``production``。"

#: ../../config.rst:58
msgid ""
"Setting :envvar:`FLASK_ENV` to ``development`` will enable debug mode. ``flask "
"run`` will use the interactive debugger and reloader by default in debug mode. "
"To control this separately from the environment, use the :envvar:`FLASK_DEBUG` "
"flag."
msgstr ""
"将环境变量 :envvar:`FLASK_ENV` 设置为 ``development`` 会启用调试模式。``flask "
"run`` 命令将会启用可交互的 Debugger 和 Reloader。要单独控制调试模式，可以使用 :"
"envvar:`FLASK_DEBUG` 环境变量。"

#: ../../config.rst:63
msgid ""
"Added :envvar:`FLASK_ENV` to control the environment separately from debug "
"mode. The development environment enables debug mode."
msgstr ""
"增加的 :envvar:`FLASK_ENV` 环境变量可以用来和调试模式区分开，从而单独的控制运行"
"环境。开发的运行环境会启用调试模式。"

#: ../../config.rst:67
msgid ""
"To switch Flask to the development environment and enable debug mode, set :"
"envvar:`FLASK_ENV`:"
msgstr ""
"想要设置开发运行环境并且启用调试模式，可以设置环境变量 :envvar:`FLASK_ENV`："

#: ../../config.rst:72 ../../config.rst:440 ../../config.rst:511
msgid "Bash"
msgstr "Bash"

#: ../../config.rst:79 ../../config.rst:448 ../../config.rst:520
msgid "CMD"
msgstr "CMD"

#: ../../config.rst:86 ../../config.rst:456 ../../config.rst:529
msgid "Powershell"
msgstr "Powershell"

#: ../../config.rst:93
msgid ""
"Using the environment variables as described above is recommended. While it is "
"possible to set :data:`ENV` and :data:`DEBUG` in your config or code, this is "
"strongly discouraged. They can't be read early by the ``flask`` command, and "
"some systems or extensions may have already configured themselves based on a "
"previous value."
msgstr ""
"我们推荐像上面这样使用环境变量。尽管你可以在配置或者代码中使用 :data:`ENV` 和 :"
"data:`DEBUG`，但我们强烈不建议你这样做。因为在运行 ``flask`` 命令之前它们可能就"
"会被读取，并且某些系统或者扩展可能已经根据之前的值对它们进行了配置。"

#: ../../config.rst:101
msgid "Builtin Configuration Values"
msgstr "内建配置值"

#: ../../config.rst:103
msgid "The following configuration values are used internally by Flask:"
msgstr "Flask 在内部使用了以下这些配置值："

#: ../../config.rst:107
msgid ""
"What environment the app is running in. Flask and extensions may enable "
"behaviors based on the environment, such as enabling debug mode. The :attr:"
"`~flask.Flask.env` attribute maps to this config key. This is set by the :"
"envvar:`FLASK_ENV` environment variable and may not behave as expected if set "
"in code."
msgstr ""
"表明了应用在什么样的环境中运行。Flask 和扩展们可能会根据不同的环境启用不同的行"
"为，像是启用调试模式。:attr:`~flask.Flask.env` 属性映射到该配置值。它本身由 :"
"envvar:`FLASK_ENV` 环境变量设置，如果在代码中对其进行设置，那么它可能不会像预期"
"那样起作用。"

#: ../../config.rst:113
msgid "**Do not enable development when deploying in production.**"
msgstr "**在生产环境中部署时请勿将该值配置为开发模式。**"

#: ../../config.rst:115
msgid "Default: ``'production'``"
msgstr "默认值：``'production'``"

#: ../../config.rst:121
msgid ""
"Whether debug mode is enabled. When using ``flask run`` to start the "
"development server, an interactive debugger will be shown for unhandled "
"exceptions, and the server will be reloaded when code changes. The :attr:"
"`~flask.Flask.debug` attribute maps to this config key. This is enabled when :"
"data:`ENV` is ``'development'`` and is overridden by the ``FLASK_DEBUG`` "
"environment variable. It may not behave as expected if set in code."
msgstr ""
"表示是否启用了调试模式。当使用 ``flask run`` 启动开发服务器，对于未处理的异常，"
"将会显示一个可交互的 Debugger；并且当代码发生更改时，服务器将会自动重新加载。:"
"attr:`~flask.Flask.debug` 属性映射到该配置值。当 :data:`ENV` 为 "
"``'development'`` 时将会启用调试模式，该配置值也会被 ``FLASK_DEBUG`` 环境变量覆"
"盖。如果在代码中对其进行设置，那么它可能不会像预期那样起作用。"

#: ../../config.rst:129
msgid "**Do not enable debug mode when deploying in production.**"
msgstr "**在生产环境中请勿启用调试模式。**"

#: ../../config.rst:131
msgid ""
"Default: ``True`` if :data:`ENV` is ``'development'``, or ``False`` otherwise."
msgstr ""
"默认值：当 :data:`ENV` 为 ``'development'`` 时为 ``True``，否则为 ``False``。"

#: ../../config.rst:136
msgid ""
"Enable testing mode. Exceptions are propagated rather than handled by the the "
"app's error handlers. Extensions may also change their behavior to facilitate "
"easier testing. You should enable this in your own tests."
msgstr ""
"是否启用测试模式。在该模式下的异常将会被传递，而不会被应用的错误处理代码处理。扩"
"展们也可以更改他们的行为以方便测试。你应该在自己的测试中启用该功能。"

#: ../../config.rst:140 ../../config.rst:164 ../../config.rst:225
#: ../../config.rst:263 ../../config.rst:347 ../../config.rst:368
msgid "Default: ``False``"
msgstr "默认值：``False``"

#: ../../config.rst:144
msgid ""
"Exceptions are re-raised rather than being handled by the app's error handlers. "
"If not set, this is implicitly true if ``TESTING`` or ``DEBUG`` is enabled."
msgstr ""
"使异常被重新抛出而不是被应用的错误处理代码接管。如果没有设置它，那么在 "
"``TESTING`` 或 ``DEBUG`` 启用时，它默认打开。"

#: ../../config.rst:148 ../../config.rst:156 ../../config.rst:174
#: ../../config.rst:188 ../../config.rst:203 ../../config.rst:210
#: ../../config.rst:233 ../../config.rst:277 ../../config.rst:295
#: ../../config.rst:322 ../../config.rst:360
msgid "Default: ``None``"
msgstr "默认值：``None``"

#: ../../config.rst:152
msgid ""
"Don't pop the request context when an exception occurs. If not set, this is "
"true if ``DEBUG`` is true. This allows debuggers to introspect the request data "
"on errors, and should normally not need to be set directly."
msgstr ""
"保留当异常发生时的请求上下文。如果没有设置，当 ``DEBUG`` 为 True 时该值默认为 "
"True。它允许 Debugger 在出现异常时对请求数据进行检查，该值通常不需要直接设置。"

#: ../../config.rst:160
msgid ""
"If there is no handler for an ``HTTPException``-type exception, re-raise it to "
"be handled by the interactive debugger instead of returning it as a simple "
"error response."
msgstr ""
"对于 ``HTTPException`` 类型的错误，如果没有被捕获，那么它将被交给交互式 "
"Debugger 处理，而不是简单的返回一个错误响应。"

#: ../../config.rst:168
msgid ""
"Trying to access a key that doesn't exist from request dicts like ``args`` and "
"``form`` will return a 400 Bad Request error page. Enable this to treat the "
"error as an unhandled exception instead so that you get the interactive "
"debugger. This is a more specific version of ``TRAP_HTTP_EXCEPTIONS``. If "
"unset, it is enabled in debug mode."
msgstr ""
"当试图从 ``args`` 和 ``form`` 等请求字典中访问一个不存在的键时，将会返回一个 "
"400 Bad Request 页面。启用该功能之后，该错误就会被当作一个未处理的异常处理，这样"
"你就可以获得交互式 Debugger 用于调试。这是 ``TRAP_HTTP_EXCEPTIONS`` 的一个更具体"
"的版本。如果没有设置该选项，在调试模式下它会被默认启用。"

#: ../../config.rst:178
msgid ""
"A secret key that will be used for securely signing the session cookie and can "
"be used for any other security related needs by extensions or your application. "
"It should be a long random ``bytes`` or ``str``. For example, copy the output "
"of this to your config::"
msgstr ""
"该密钥将被用于安全地签署 Session Cookie，还可以用于扩展，以及任何你应用中关于安"
"全的其他需求。它应该是一个足够长的随机 ``bytes`` 或者 ``str``。举个例子，你可以"
"把下面的输出复制到你的配置中："

#: ../../config.rst:186
msgid ""
"**Do not reveal the secret key when posting questions or committing code.**"
msgstr "**在提问或者提交代码的时候注意不要泄漏密钥**"

#: ../../config.rst:192
msgid ""
"The name of the session cookie. Can be changed in case you already have a "
"cookie with the same name."
msgstr "Session Cookie 的名称。如果你有一个同名的 Cookie，那么可以更改它。"

#: ../../config.rst:195
msgid "Default: ``'session'``"
msgstr "默认值：``'session'``"

#: ../../config.rst:199
msgid ""
"The domain match rule that the session cookie will be valid for. If not set, "
"the cookie will be valid for all subdomains of :data:`SERVER_NAME`. If "
"``False``, the cookie's domain will not be set."
msgstr ""
"这是 Session Cookie 的作用域规则。如果没有被设置，那么 Cookie 将会对 :data:"
"`SERVER_NAME` 的所有子域生效。如果设置为 ``False``，那么 Cookie 的作用域将不会被设"
"置。"

#: ../../config.rst:207
msgid ""
"The path that the session cookie will be valid for. If not set, the cookie will "
"be valid underneath ``APPLICATION_ROOT`` or ``/`` if that is not set."
msgstr ""
"指明 Session Cookie 的有效路径。如果没有设置，那么 Cookie 将在 "
"``APPLICATION_ROOT`` 下有效，如果该配置也没有被设置，那么 Cookie 将在 `/` 下有效。"

#: ../../config.rst:214
msgid ""
"Browsers will not allow JavaScript access to cookies marked as \"HTTP only\" "
"for security."
msgstr ""
"浏览器为了保证安全，将不允许 JavaScript 代码访问标记为 “HTTP only” 的 Cookies。"

#: ../../config.rst:217 ../../config.rst:255 ../../config.rst:331
#: ../../config.rst:340
msgid "Default: ``True``"
msgstr "默认值：``True``"

#: ../../config.rst:221
msgid ""
"Browsers will only send cookies with requests over HTTPS if the cookie is "
"marked \"secure\". The application must be served over HTTPS for this to make "
"sense."
msgstr ""
"当 Cookie 被标记为“安全”时，浏览器将仅通过 HTTPS 发送 Cookie。如果要使得该配置有"
"意义，你的应用必须通过 HTTPS 提供服务。"

#: ../../config.rst:229
msgid ""
"Restrict how cookies are sent with requests from external sites. Can be set to "
"``'Lax'`` (recommended) or ``'Strict'``. See :ref:`security-cookie`."
msgstr ""
"用于限制 Cookies 随请求发送至外域。可以被设置为 ``'Lax'`` （推荐值）或者 "
"``'Strict'``。具体查看 :ref:`security-cookie`。"

#: ../../config.rst:239
msgid ""
"If ``session.permanent`` is true, the cookie's expiration will be set this "
"number of seconds in the future. Can either be a :class:`datetime.timedelta` or "
"an ``int``."
msgstr ""
"如果 ``session.permanent`` 被设置为 true，那么该配置值（按秒）将被设置为将来 "
"Cookie 的过期时间。它可以是一个 :class:`datetime.timedelta` 或一个 ``int`` 对"
"象。"

#: ../../config.rst:243
msgid ""
"Flask's default cookie implementation validates that the cryptographic "
"signature is not older than this value."
msgstr "Flask 的默认 Cookie 实现会验证加密签名是否比这个值大。"

#: ../../config.rst:246
msgid "Default: ``timedelta(days=31)`` (``2678400`` seconds)"
msgstr "默认值：``timedelta(days=31)`` (``2678400`` 秒)"

#: ../../config.rst:250
msgid ""
"Control whether the cookie is sent with every response when ``session."
"permanent`` is true. Sending the cookie every time (the default) can more "
"reliably keep the session from expiring, but uses more bandwidth. Non-permanent "
"sessions are not affected."
msgstr ""
"当 ``session.permanent`` 为 true 时，是否每次随响应都发送 Cookie。每次都发送 "
"Cookie（默认值）可以更可靠的保证会话不过期，但这会占用更多带宽。非永久会话不受该"
"配置影响。"

#: ../../config.rst:259
msgid ""
"When serving files, set the ``X-Sendfile`` header instead of serving the data "
"with Flask. Some web servers, such as Apache, recognize this and serve the data "
"more efficiently. This only makes sense when using such a server."
msgstr ""
"当提供文件时，设置 ``X-Sendfile`` 头而不是使用 Flask 本身提供数据。某些像是 "
"Apache 之类的伺服器会识别该头并更有效率的发送文件数据。当且仅当使用了类似的伺服"
"器时，该配置才有意义。"

#: ../../config.rst:267
msgid ""
"When serving files, set the cache control max age to this number of seconds. "
"Can be a :class:`datetime.timedelta` or an ``int``. Override this value on a "
"per-file basis using :meth:`~flask.Flask.get_send_file_max_age` on the "
"application or blueprint."
msgstr ""
"当提供文件时，该配置值（按秒）将被设置为缓存控制的最大值。它可以是一个 :class:"
"`datetime.timedelta` 或一个 ``int`` 对象。你可以使用 :meth:`~flask.Flask."
"get_send_file_max_age` 来在应用程序或者蓝图中针对每个文件覆盖该值。"

#: ../../config.rst:273
msgid ""
"If ``None``, ``send_file`` tells the browser to use conditional requests will "
"be used instead of a timed cache, which is usually preferable."
msgstr ""
"如果为 ``None``，那么 ``send_file`` 将告诉浏览器使用条件请求而不是基于时间的缓存"
"控制，我们通常都这么做。"

#: ../../config.rst:281
msgid ""
"Inform the application what host and port it is bound to. Required for "
"subdomain route matching support."
msgstr ""
"告知应用程序它被绑定到的主机名以及端口。这在提供子域路由匹配支持时是必须的。"

#: ../../config.rst:284
msgid ""
"If set, will be used for the session cookie domain if :data:"
"`SESSION_COOKIE_DOMAIN` is not set. Modern web browsers will not allow setting "
"cookies for domains without a dot. To use a domain locally, add any names that "
"should route to the app to your ``hosts`` file. ::"
msgstr ""
"如果该配置被设置并且 :data:`SESSION_COOKIE_DOMAIN` 未被设置，那么 Cookie 域将被"
"设置为该值。现代浏览器通常不允许设置不带点的 Cookie 域。要想在本地使用一个域，请将"
"所有路由到你应用程序的域名添加到 ``hosts`` 文件："

#: ../../config.rst:292
msgid ""
"If set, ``url_for`` can generate external URLs with only an application context "
"instead of a request context."
msgstr ""
"如果它被设置，``url_for`` 仅可以产生应用程序上下文而不是请求上下文中的外部 URL。"

#: ../../config.rst:299
msgid ""
"Inform the application what path it is mounted under by the application / web "
"server.  This is used for generating URLs outside the context of a request "
"(inside a request, the dispatcher is responsible for setting ``SCRIPT_NAME`` "
"instead; see :doc:`/patterns/appdispatch` for examples of dispatch "
"configuration)."
msgstr ""
"告诉应用程序它被挂载在应用 / Web 服务器的什么路径下。它可以用于在请求上下文外生"
"成 URL（在请求上下文内部，调度器负责设置 ``SCRIPT_NAME``；关于调度配置的示例，请"
"看 :doc:`/patterns/appdispatch`）。"

#: ../../config.rst:305
msgid ""
"Will be used for the session cookie path if ``SESSION_COOKIE_PATH`` is not set."
msgstr ""
"如果没有设置 ``SESSION_COOKIE_PATH``，那么该值将被用于配置 Session 与 Cookie 的"
"路径。"

#: ../../config.rst:308
msgid "Default: ``'/'``"
msgstr "默认值：``'/'``"

#: ../../config.rst:312
msgid ""
"Use this scheme for generating external URLs when not in a request context."
msgstr "当不再请求上下文中时，该配置被用来生成外部 URL。"

#: ../../config.rst:314
msgid "Default: ``'http'``"
msgstr "默认值：``'http'``"

#: ../../config.rst:318
msgid ""
"Don't read more than this many bytes from the incoming request data. If not set "
"and the request does not specify a ``CONTENT_LENGTH``, no data will be read for "
"security."
msgstr ""
"传入的请求数据中超过这个字节的数据将不会被读取。如果没有设置，并且请求没有指定 "
"``CONTENT_LENGTH``，那么为了安全，将不会读取任何数据。"

#: ../../config.rst:326
msgid ""
"Serialize objects to ASCII-encoded JSON. If this is disabled, the JSON returned "
"from ``jsonify`` will contain Unicode characters. This has security "
"implications when rendering the JSON into JavaScript in templates, and should "
"typically remain enabled."
msgstr ""
"将对象序列化成 ASCII 编码的 JSON。如果该配置被禁用，那么在 ``jsonfiy`` 所返回的 "
"JSON 中将可能包含 Unicode 字符。如果在模板中将 JSON 渲染为了 JavaScript 对象，这"
"可能会影响安全性，通常该选项保持打开。"

#: ../../config.rst:335
msgid ""
"Sort the keys of JSON objects alphabetically. This is useful for caching "
"because it ensures the data is serialized the same way no matter what Python's "
"hash seed is. While not recommended, you can disable this for a possible "
"performance improvement at the cost of caching."
msgstr ""
"将 JSON 对象的键按照字母顺序排序。这对缓存来说会有用，因为无论 Python 的哈希种子"
"是什么，数据都可以以相同的方式被序列化。你可以禁用它，虽然我们不推荐这样做 —— 以"
"缓存命中率为代价获取可能的性能提升。"

#: ../../config.rst:344
msgid ""
"``jsonify`` responses will be output with newlines, spaces, and indentation for "
"easier reading by humans. Always enabled in debug mode."
msgstr ""
"``jsonify`` 函数的响应将包含换行符、空格以及缩进，这将方便人类阅读。在调试模式下"
"该选项将被启用。"

#: ../../config.rst:351
msgid "The mimetype of ``jsonify`` responses."
msgstr "``jsonfiy`` 响应的 Mimetype。"

#: ../../config.rst:353
msgid "Default: ``'application/json'``"
msgstr "默认值：``'application/json'``"

#: ../../config.rst:357
msgid ""
"Reload templates when they are changed. If not set, it will be enabled in debug "
"mode."
msgstr ""
"如果模板发生了改变，重新加载它。如果没有被设置，在调试模式下将被默认启用。"

#: ../../config.rst:364
msgid ""
"Log debugging information tracing how a template file was loaded. This can be "
"useful to figure out why a template was not loaded or the wrong file appears to "
"be loaded."
msgstr ""
"在调试信息中记录追踪模板文件是如何被加载的。这对搞清楚为什么一个模板没有被加载或"
"者出现加载错误是很有帮助的。"

#: ../../config.rst:372
msgid ""
"Warn if cookie headers are larger than this many bytes. Defaults to ``4093``. "
"Larger cookies may be silently ignored by browsers. Set to ``0`` to disable the "
"warning."
msgstr ""
"如果 Cookie 头大于该大小就会发出警告。默认为 ``4093``。更大的 Cookie 可以能会被"
"浏览器默认忽略。将它设置为 ``0`` 可以禁用警告。"

#: ../../config.rst:404
msgid ""
"``LOGGER_NAME`` and ``LOGGER_HANDLER_POLICY`` were removed. See :doc:`/logging` "
"for information about configuration."
msgstr ""
"``LOGGER_NAME`` 与 ``LOGGER_HANDLER_POLICY`` 被移除了。更多关于配置的信息可以查"
"看 :doc:`/logging`。"

#: ../../config.rst:408
msgid "Added :data:`ENV` to reflect the :envvar:`FLASK_ENV` environment variable."
msgstr "增加了 :data:`ENV` 用来映射 :envvar:`FLASK_ENV` 环境变量。"

#: ../../config.rst:411
msgid ""
"Added :data:`SESSION_COOKIE_SAMESITE` to control the session cookie's "
"``SameSite`` option."
msgstr ""
"增加了 :data:`SESSION_COOKIE_SAMESITE` 用于控制 Cookie 的 ``SameSite`` 选项。"

#: ../../config.rst:414
msgid "Added :data:`MAX_COOKIE_SIZE` to control a warning from Werkzeug."
msgstr "增加了 :data:`MAX_COOKIE_SIZE` 用于控制 Werkzeug 的警告。"

#: ../../config.rst:400
msgid ""
"``SESSION_REFRESH_EACH_REQUEST``, ``TEMPLATES_AUTO_RELOAD``, "
"``LOGGER_HANDLER_POLICY``, ``EXPLAIN_TEMPLATE_LOADING``"
msgstr ""
"``SESSION_REFRESH_EACH_REQUEST``， ``TEMPLATES_AUTO_RELOAD``， "
"``LOGGER_HANDLER_POLICY``， ``EXPLAIN_TEMPLATE_LOADING``"

#: ../../config.rst:397
msgid "``JSON_AS_ASCII``, ``JSON_SORT_KEYS``, ``JSONIFY_PRETTYPRINT_REGULAR``"
msgstr "``JSON_AS_ASCII``， ``JSON_SORT_KEYS``， ``JSONIFY_PRETTYPRINT_REGULAR``"

#: ../../config.rst:394
msgid "``PREFERRED_URL_SCHEME``"
msgstr "``PREFERRED_URL_SCHEME``"

#: ../../config.rst:388
msgid ""
"``TRAP_BAD_REQUEST_ERRORS``, ``TRAP_HTTP_EXCEPTIONS``, ``APPLICATION_ROOT``, "
"``SESSION_COOKIE_DOMAIN``, ``SESSION_COOKIE_PATH``, "
"``SESSION_COOKIE_HTTPONLY``, ``SESSION_COOKIE_SECURE``"
msgstr ""
"``TRAP_BAD_REQUEST_ERRORS``， ``TRAP_HTTP_EXCEPTIONS``， ``APPLICATION_ROOT``， "
"``SESSION_COOKIE_DOMAIN``， ``SESSION_COOKIE_PATH``， "
"``SESSION_COOKIE_HTTPONLY``， ``SESSION_COOKIE_SECURE``"

#: ../../config.rst:385
msgid "``PROPAGATE_EXCEPTIONS``, ``PRESERVE_CONTEXT_ON_EXCEPTION``"
msgstr "``PROPAGATE_EXCEPTIONS``， ``PRESERVE_CONTEXT_ON_EXCEPTION``"

#: ../../config.rst:382
msgid "``MAX_CONTENT_LENGTH``"
msgstr "``MAX_CONTENT_LENGTH``"

#: ../../config.rst:379
msgid "``SERVER_NAME``"
msgstr "``SERVER_NAME``"

#: ../../config.rst:376
msgid "``LOGGER_NAME``"
msgstr "``LOGGER_NAME``"

#: ../../config.rst:418
msgid "Configuring from Python Files"
msgstr "从 Python 文件中配置"

#: ../../config.rst:420
msgid ""
"Configuration becomes more useful if you can store it in a separate file, "
"ideally located outside the actual application package. This makes packaging "
"and distributing your application possible via various package handling tools (:"
"doc:`/patterns/distribute`) and finally modifying the configuration file "
"afterwards."
msgstr ""
"如果你能将配置存储在一个单独的文件中，最好是存储在实际的应用包外部，那么配置就会"
"变得更加有用。这样就可以通过使用各种包处理工具 (:doc:`/patterns/distribute`) 来"
"分发你的应用，并且可以在之后对配置进行修改。"

#: ../../config.rst:426
msgid "So a common pattern is this::"
msgstr "所以一个常用的模式像是这样："

#: ../../config.rst:432
msgid ""
"This first loads the configuration from the `yourapplication.default_settings` "
"module and then overrides the values with the contents of the file the :envvar:"
"`YOURAPPLICATION_SETTINGS` environment variable points to.  This environment "
"variable can be set in the shell before starting the server:"
msgstr ""
"首先它会从 `yourapplication.default_settings` 模块加载配置，之后用 :envvar:"
"`YOURAPPLICATION_SETTINGS` 环境变量的指向文件的内容覆盖这些默认值。这个环境变量"
"可以在启动服务器之前通过 Shell 设置："

#: ../../config.rst:464
msgid ""
"The configuration files themselves are actual Python files.  Only values in "
"uppercase are actually stored in the config object later on.  So make sure to "
"use uppercase letters for your config keys."
msgstr ""
"配置文件实际上本身就是 Python 文件。只有以大写字母命名的值才能之后被真正的存储在"
"配置对象中。所以要保证你在配置的键上使用了大写字母。"

#: ../../config.rst:468
msgid "Here is an example of a configuration file::"
msgstr "这是一份示例的配置文件："

#: ../../config.rst:473
msgid ""
"Make sure to load the configuration very early on, so that extensions have the "
"ability to access the configuration when starting up.  There are other methods "
"on the config object as well to load from individual files.  For a complete "
"reference, read the :class:`~flask.Config` object's documentation."
msgstr ""
"确保在早期时配置就被加载，这样在扩展程序在启动时就可以访问配置。也有其他的方法允"
"许从单个文件中加载配置对象。 要获得完整的参考，请阅读 :class:`~flask.Config` 类"
"的文档。"

#: ../../config.rst:481
msgid "Configuring from Data Files"
msgstr "从数据文件中加载配置"

#: ../../config.rst:483
msgid ""
"It is also possible to load configuration from a file in a format of your "
"choice using :meth:`~flask.Config.from_file`. For example to load from a TOML "
"file:"
msgstr ""
"你也可以使用 :meth:`~flask.Config.from_file` 从你现有格式的配置文件中加载配置。"
"例如，从 TOML 文件中加载："

#: ../../config.rst:492
msgid "Or from a JSON file:"
msgstr "或者从一个 JSON 文件中加载："

#: ../../config.rst:501
msgid "Configuring from Environment Variables"
msgstr "从环境变量中配置"

#: ../../config.rst:503
msgid ""
"In addition to pointing to configuration files using environment variables, you "
"may find it useful (or necessary) to control your configuration values directly "
"from the environment."
msgstr ""
"除了使用环境变量指向配置文件外，你可能会发现直接从环境变量中控制配置值是很有用的"
"（或者说，有必要的）。"

#: ../../config.rst:507
msgid "Environment variables can be set in the shell before starting the server:"
msgstr "环境变量可以在启动服务之前就在 Shell 中设置："

#: ../../config.rst:538
msgid ""
"While this approach is straightforward to use, it is important to remember that "
"environment variables are strings -- they are not automatically deserialized "
"into Python types."
msgstr ""
"虽然这种方法使用起来很直接，但是重要的是要记住环境变量是字符串 —— 它们不会被自动"
"反序列化成 Python 类实例。"

#: ../../config.rst:542
msgid ""
"Here is an example of a configuration file that uses environment variables::"
msgstr "下面是一个在配置文件中使用环境变量的例子："

#: ../../config.rst:555
msgid ""
"Notice that any value besides an empty string will be interpreted as a boolean "
"``True`` value in Python, which requires care if an environment explicitly sets "
"values intended to be ``False``."
msgstr ""
"需要注意的是，除了空字符串之外的任何值在 Python 布尔类型中都将被解释为 "
"``True``，如果环境明确的设置某个值为 ``False``，则需要小心处理。"

#: ../../config.rst:559
msgid ""
"Make sure to load the configuration very early on, so that extensions have the "
"ability to access the configuration when starting up.  There are other methods "
"on the config object as well to load from individual files.  For a complete "
"reference, read the :class:`~flask.Config` class documentation."
msgstr ""
"确保在早期时配置就被加载，这样在扩展程序在启动时就可以访问配置。也有其他的方法允"
"许从单个文件中加载配置对象。 要获得完整的参考，请阅读 :class:`~flask.Config` 类"
"的文档。"

#: ../../config.rst:566
msgid "Configuration Best Practices"
msgstr "配置的最佳实践"

#: ../../config.rst:568
#, python-format
msgid ""
"The downside with the approach mentioned earlier is that it makes testing a "
"little harder.  There is no single 100% solution for this problem in general, "
"but there are a couple of things you can keep in mind to improve that "
"experience:"
msgstr ""
"前面提到的方法有一些缺点：它会使得测试变得有些困难。一般来说，这个问题没有一个完"
"美的解决方案，但是记住这几件事可以改善我们的测试体验："

#: ../../config.rst:573
msgid ""
"Create your application in a function and register blueprints on it. That way "
"you can create multiple instances of your application with different "
"configurations attached which makes unit testing a lot easier.  You can use "
"this to pass in configuration as needed."
msgstr ""
"在一个函数中创建应用，并在程序中使用蓝图。这样你就可以使用不同的配置来创建不同的"
"应用程序实例，这可以让单元测试变得更加容易。你可以利用这一点，根据需要传入配置。"

#: ../../config.rst:578
msgid ""
"Do not write code that needs the configuration at import time.  If you limit "
"yourself to request-only accesses to the configuration you can reconfigure the "
"object later on as needed."
msgstr ""
"不要写出在导入时就需要配置值的代码。如果你限制自己仅对配置进行请求访问，那么你就"
"可以在以后根据需要重新配置对象。"

#: ../../config.rst:585
msgid "Development / Production"
msgstr "开发环境/生产环境"

#: ../../config.rst:587
msgid ""
"Most applications need more than one configuration.  There should be at least "
"separate configurations for the production server and the one used during "
"development.  The easiest way to handle this is to use a default configuration "
"that is always loaded and part of the version control, and a separate "
"configuration that overrides the values as necessary as mentioned in the "
"example above::"
msgstr ""
"大多数的应用都需要不止一套配置。应用至少应该有一套用于开发服务器使用的配置以及一"
"套用于生产环境的配置。这个问题最简单的解决方案是使用一个总是被加载的默认配置加上"
"一个使用版本控制的部分配置，这样就可以在上面提到的例子中覆盖部分配置值："

#: ../../config.rst:598
msgid ""
"Then you just have to add a separate :file:`config.py` file and export "
"``YOURAPPLICATION_SETTINGS=/path/to/config.py`` and you are done.  However "
"there are alternative ways as well.  For example you could use imports or "
"subclassing."
msgstr ""
"这样你就只需要单独地添加配置文件 :file:`config.py` 并使用 "
"``YOURAPPLICATION_SETTINGS=/path/to/config.py`` 将它导出到环境变量。尽管也有其他"
"方法，例如使用子类。"

#: ../../config.rst:603
msgid ""
"What is very popular in the Django world is to make the import explicit in the "
"config file by adding ``from yourapplication.default_settings import *`` to the "
"top of the file and then overriding the changes by hand. You could also inspect "
"an environment variable like ``YOURAPPLICATION_MODE`` and set that to "
"`production`, `development` etc and import different hard-coded files based on "
"that."
msgstr ""
"在 Django 世界中非常流行的是在配置文件中显式导入，通过在文件顶部添加 ``from "
"yourapplication.default_settings import *`` 并进行手动覆盖。你也可以管理一个像"
"是 ``YOURAPPLICATION_MODE`` 的环境变量，并将其设置为 `production`、"
"`development` 之类的值，并基于此导入不同的硬编码文件。"

#: ../../config.rst:610
msgid ""
"An interesting pattern is also to use classes and inheritance for "
"configuration::"
msgstr "使用类继承也是进行配置的一个有趣方式："

#: ../../config.rst:626
msgid ""
"To enable such a config you just have to call into :meth:`~flask.Config."
"from_object`::"
msgstr "要启用这个配置，只需要调用 :meth:`~flask.Config.from_object`："

#: ../../config.rst:631
msgid ""
"Note that :meth:`~flask.Config.from_object` does not instantiate the class "
"object. If you need to instantiate the class, such as to access a property, "
"then you must do so before calling :meth:`~flask.Config.from_object`::"
msgstr ""
"请注意 :meth:`~flask.Config.from_object` 并不实例化类。如果你需要要访问类的一个"
"属性，那么必须在调用 :meth:`~flask.Config.from_object` 之前就对它进行实例化："

#: ../../config.rst:643
msgid ""
"Instantiating the configuration object allows you to use ``@property`` in your "
"configuration classes::"
msgstr "实例化配置对象允许你在配置类中使用 ``@property``："

#: ../../config.rst:666
msgid ""
"There are many different ways and it's up to you how you want to manage your "
"configuration files.  However here a list of good recommendations:"
msgstr ""
"有很多不同的管理配置文件的方法，怎么使用它们取决于你。不过仍然有一些不错的建议："

#: ../../config.rst:669
msgid ""
"Keep a default configuration in version control.  Either populate the config "
"with this default configuration or import it in your own configuration files "
"before overriding values."
msgstr ""
"在你的版本控制中保留一个默认配置。在覆盖配置值之前，要么用默认配置来填充，要么在"
"要使用的配置中导入这个默认配置。"

#: ../../config.rst:672
msgid ""
"Use an environment variable to switch between the configurations. This can be "
"done from outside the Python interpreter and makes development and deployment "
"much easier because you can quickly and easily switch between different configs "
"without having to touch the code at all.  If you are working often on different "
"projects you can even create your own script for sourcing that activates a "
"virtualenv and exports the development configuration for you."
msgstr ""
"使用环境变量来切换配置。它可以在 Python 解释器之外完成，并使得开发和部署变得更加"
"容易，因为你可以很快速轻松的在不同的配置之间进行切换，而根本不需要改动代码。如果"
"你经常要在不同的项目上进行开发，你甚至可以写一个脚本为你管理激活的 virtualenv 环"
"境并导出对应的开发配置。"

#: ../../config.rst:679
msgid ""
"Use a tool like `fabric`_ in production to push code and configurations "
"separately to the production server(s).  For some details about how to do that, "
"head over to the :doc:`/patterns/fabric` pattern."
msgstr ""
"使用像是 `fabric`_ 这样的工具，将代码和配置分别推送到服务器上。关于如何做到这一"
"点的更多细节，请参考 :doc:`/patterns/fabric` 的模式。"

#: ../../config.rst:690
msgid "Instance Folders"
msgstr "实例文件夹"

#: ../../config.rst:694
msgid ""
"Flask 0.8 introduces instance folders.  Flask for a long time made it possible "
"to refer to paths relative to the application's folder directly (via :attr:"
"`Flask.root_path`).  This was also how many developers loaded configurations "
"stored next to the application.  Unfortunately however this only works well if "
"applications are not packages in which case the root path refers to the "
"contents of the package."
msgstr ""
"Flask 0.8 引入了实例文件夹的概念。Flask 在很长的一段时间内都可以直接引用应用文件"
"夹路径（通过 :attr:`Flask.root_path`）。这也是很多开发者加载存储在应用目录内配置"
"文件的方式。但是很不幸，这只在应用程序不是包的情况下工作的很好，在这种情况下，根"
"路径指向的是包的内容。"

#: ../../config.rst:701
msgid ""
"With Flask 0.8 a new attribute was introduced: :attr:`Flask.instance_path`.  It "
"refers to a new concept called the “instance folder”.  The instance folder is "
"designed to not be under version control and be deployment specific.  It's the "
"perfect place to drop things that either change at runtime or configuration "
"files."
msgstr ""
"从 Flask 0.8 开始，一个新的 :attr:`Flask.instance_path` 属性被引入。它指的是一个"
"叫做“实例文件夹”的新概念。实例文件夹被设计为不受版本控制管理，而是依赖于部署。如"
"果有什么在运行时需要改变的东西，或者是配置文件，这是存放它们的完美地方。"

#: ../../config.rst:707
msgid ""
"You can either explicitly provide the path of the instance folder when creating "
"the Flask application or you can let Flask autodetect the instance folder.  For "
"explicit configuration use the `instance_path` parameter::"
msgstr ""
"当创建 Flask 应用时，你可以显式的提供实例文件夹的路径，也可以让 Flask 去自动检测"
"实例文件夹。如果要显式配置使用实例文件夹，请使用 `instance_path` 参数："

#: ../../config.rst:714
msgid "Please keep in mind that this path *must* be absolute when provided."
msgstr "请记住提供的该路径 *一定* 要是绝对路径。"

#: ../../config.rst:716
msgid ""
"If the `instance_path` parameter is not provided the following default "
"locations are used:"
msgstr "如果没有提供 `instance_path` 参数，默认使用这些位置："

#: ../../config.rst:719
msgid "Uninstalled module::"
msgstr "卸载的模块："

#: ../../config.rst:724
msgid "Uninstalled package::"
msgstr "卸载的包："

#: ../../config.rst:730
msgid "Installed module or package::"
msgstr "加载的模块与包："

#: ../../config.rst:735
msgid ""
"``$PREFIX`` is the prefix of your Python installation.  This can be ``/usr`` or "
"the path to your virtualenv.  You can print the value of ``sys.prefix`` to see "
"what the prefix is set to."
msgstr ""
"``$PREFIX`` 是你的 Python 安装路径.  它可能是 ``/usr`` 或者是你 virtualenv 的路"
"径.  你可以使用 ``sys.prefix`` 用于检查该路径的值。"

#: ../../config.rst:739
msgid ""
"Since the config object provided loading of configuration files from relative "
"filenames we made it possible to change the loading via filenames to be "
"relative to the instance path if wanted.  The behavior of relative paths in "
"config files can be flipped between “relative to the application root” (the "
"default) to “relative to instance folder” via the `instance_relative_config` "
"switch to the application constructor::"
msgstr ""
"由于配置对象提供了通过相对路径加载配置文件的功能，所以如果需要的话，我们可以将通"
"过文件名加载配置文件的方式改为通过相对于实例目录的方式。加载配置文件的相对路径可"
"以通过应用的 `instance_relative_config` 开关控制，在“相对于应用根目录”与“相对于"
"实例文件夹”之间切换："

#: ../../config.rst:748
msgid ""
"Here is a full example of how to configure Flask to preload the config from a "
"module and then override the config from a file in the instance folder if it "
"exists::"
msgstr ""
"这是一个关于如何将 Flask 配置为首先从模块加载配置，之后再从实例文件夹中加载覆盖"
"配置的例子（如果存在该文件的话）："

#: ../../config.rst:756
msgid ""
"The path to the instance folder can be found via the :attr:`Flask."
"instance_path`.  Flask also provides a shortcut to open a file from the "
"instance folder with :meth:`Flask.open_instance_resource`."
msgstr ""
"实例文件夹的路径可以通过 :attr:`Flask.instance_path` 查看。除此之外，Flask 还提"
"供了一个快捷方式，通过 :meth:`Flask.open_instance_resource` 来打开实例文件夹中的"
"文件。"

#: ../../config.rst:760
msgid "Example usage for both::"
msgstr "一起使用它们的例子："
